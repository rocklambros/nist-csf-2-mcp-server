<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate">
    <meta http-equiv="Pragma" content="no-cache">
    <meta http-equiv="Expires" content="0">
    <title>NIST CSF 2.0 Assessment v2025.09.08-NAVIGATION-FIXED</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            color: #333;
        }
        
        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
        }
        
        .header {
            background: white;
            padding: 24px;
            border-radius: 12px;
            box-shadow: 0 4px 16px rgba(0,0,0,0.1);
            margin-bottom: 24px;
            text-align: center;
        }
        
        .header h1 {
            color: #2c3e50;
            font-size: 2.5rem;
            margin-bottom: 8px;
        }
        
        .header p {
            color: #7f8c8d;
            font-size: 1.1rem;
        }
        
        .progress-section {
            background: white;
            padding: 20px;
            border-radius: 12px;
            box-shadow: 0 4px 16px rgba(0,0,0,0.1);
            margin-bottom: 24px;
        }
        
        .progress-bar {
            background: #ecf0f1;
            border-radius: 25px;
            height: 12px;
            overflow: hidden;
            margin-bottom: 16px;
        }
        
        .progress-fill {
            background: linear-gradient(90deg, #3498db, #2ecc71);
            height: 100%;
            border-radius: 25px;
            transition: width 0.3s ease;
            width: 0%;
        }
        
        .progress-text {
            font-size: 1.1rem;
            font-weight: 600;
            color: #2c3e50;
            text-align: center;
        }
        
        .organization-setup {
            background: white;
            padding: 24px;
            border-radius: 12px;
            box-shadow: 0 4px 16px rgba(0,0,0,0.1);
            margin-bottom: 24px;
        }
        
        .form-group {
            margin-bottom: 20px;
        }
        
        .form-group label {
            display: block;
            margin-bottom: 8px;
            font-weight: 600;
            color: #2c3e50;
        }
        
        .form-group input, .form-group select {
            width: 100%;
            padding: 12px;
            border: 2px solid #ecf0f1;
            border-radius: 8px;
            font-size: 1rem;
            transition: border-color 0.3s ease;
        }
        
        .form-group input:focus, .form-group select:focus {
            outline: none;
            border-color: #3498db;
        }
        
        .btn {
            background: linear-gradient(135deg, #3498db, #2980b9);
            color: white;
            padding: 12px 24px;
            border: none;
            border-radius: 8px;
            font-size: 1rem;
            cursor: pointer;
            transition: transform 0.2s ease;
        }
        
        .btn:hover {
            transform: translateY(-2px);
        }
        
        .btn:disabled {
            opacity: 0.6;
            cursor: not-allowed;
            transform: none;
        }
        
        .category-grid, .function-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 20px;
            margin-bottom: 24px;
        }
        
        .function-cards {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 15px;
            margin-top: 20px;
        }
        
        .function-card {
            background: linear-gradient(135deg, #f8f9fa, #e9ecef);
            border: 2px solid #dee2e6;
            border-radius: 12px;
            padding: 20px;
            text-align: center;
            cursor: pointer;
            transition: all 0.3s ease;
        }
        
        .function-card:hover {
            background: linear-gradient(135deg, #3498db, #2980b9);
            color: white;
            border-color: #2980b9;
            transform: translateY(-5px);
            box-shadow: 0 8px 25px rgba(52, 152, 219, 0.3);
        }
        
        .function-title {
            font-size: 1.4em;
            font-weight: bold;
            margin-bottom: 8px;
        }
        
        .function-id {
            font-size: 0.9em;
            opacity: 0.8;
            font-family: monospace;
        }
        
        .function-description {
            font-size: 0.95em;
            margin: 10px 0;
            line-height: 1.4;
        }
        
        .function-stats {
            font-size: 0.9em;
            color: #666;
            margin-top: 8px;
        }
        
        .function-progress {
            font-size: 0.85em;
            color: #3498db;
            font-weight: bold;
            margin-top: 5px;
        }
        
        .navigation-breadcrumb {
            background: #f8f9fa;
            padding: 12px 16px;
            border-radius: 8px;
            margin-bottom: 20px;
            font-weight: 500;
        }
        
        .breadcrumb-link {
            background: transparent;
            border: none;
            color: #3498db;
            cursor: pointer;
            text-decoration: underline;
            font-size: inherit;
            margin-left: 10px;
        }
        
        .category-card {
            background: white;
            padding: 20px;
            border-radius: 12px;
            box-shadow: 0 4px 16px rgba(0,0,0,0.1);
            cursor: pointer;
            transition: all 0.3s ease;
            border-left: 5px solid #bdc3c7;
        }
        
        .category-card:hover {
            transform: translateY(-4px);
            box-shadow: 0 8px 24px rgba(0,0,0,0.15);
        }
        
        .category-card.completed {
            border-left-color: #27ae60;
        }
        
        .category-card.in-progress {
            border-left-color: #f39c12;
        }
        
        .category-card.not-started {
            border-left-color: #e74c3c;
        }
        
        .category-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 12px;
        }
        
        .category-title {
            font-size: 1.2rem;
            font-weight: 600;
            color: #2c3e50;
        }
        
        .category-progress {
            font-size: 0.9rem;
            font-weight: 600;
        }
        
        .category-progress.completed {
            color: #27ae60;
        }
        
        .category-progress.in-progress {
            color: #f39c12;
        }
        
        .category-progress.not-started {
            color: #e74c3c;
        }
        
        .category-description {
            color: #7f8c8d;
            line-height: 1.5;
        }
        
        .question-container {
            background: white;
            padding: 24px;
            border-radius: 12px;
            box-shadow: 0 4px 16px rgba(0,0,0,0.1);
            margin-bottom: 24px;
            display: none;
        }
        
        .question-header {
            margin-bottom: 20px;
        }
        
        .question-number {
            color: #7f8c8d;
            font-size: 0.9rem;
            font-weight: 600;
        }
        
        .question-text {
            font-size: 1.3rem;
            color: #2c3e50;
            line-height: 1.6;
            margin: 12px 0;
        }
        
        .question-options {
            margin: 20px 0;
        }
        
        .option {
            display: flex;
            align-items: center;
            padding: 12px;
            margin: 8px 0;
            background: #f8f9fa;
            border-radius: 8px;
            cursor: pointer;
            transition: background-color 0.2s ease;
        }
        
        .option:hover {
            background: #e9ecef;
        }
        
        .option input[type="radio"] {
            margin-right: 12px;
        }
        
        .option label {
            cursor: pointer;
            flex: 1;
        }
        
        .confidence-section {
            margin: 20px 0;
            padding: 16px;
            background: #f8f9fa;
            border-radius: 8px;
        }
        
        .confidence-section label {
            display: block;
            margin-bottom: 8px;
            font-weight: 600;
        }
        
        .notes-section {
            margin: 20px 0;
        }
        
        .notes-section textarea {
            width: 100%;
            padding: 12px;
            border: 2px solid #ecf0f1;
            border-radius: 8px;
            font-family: inherit;
            resize: vertical;
            min-height: 80px;
        }
        
        .question-navigation {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-top: 24px;
            flex-wrap: wrap;
            gap: 10px;
        }
        
        .question-navigation .nav-buttons-left {
            display: flex;
            gap: 10px;
            align-items: center;
        }
        
        .auto-save-indicator {
            display: flex;
            align-items: center;
            color: #27ae60;
            font-size: 0.9rem;
        }
        
        .auto-save-indicator.saving {
            color: #f39c12;
        }
        
        .auto-save-indicator.error {
            color: #e74c3c;
        }
        
        .hidden {
            display: none;
        }
        
        .loading {
            text-align: center;
            padding: 40px;
            color: #7f8c8d;
        }

        /* Completion Screen Styles */
        .completion-screen {
            max-width: 1000px;
            margin: 0 auto;
            padding: 20px;
        }

        .completion-header {
            text-align: center;
            margin-bottom: 30px;
            padding: 20px;
            background: linear-gradient(135deg, #27ae60, #2ecc71);
            color: white;
            border-radius: 10px;
        }

        .completion-header h2 {
            margin: 0 0 10px 0;
            font-size: 2.2em;
        }

        .completion-summary {
            background: #f8f9fa;
            padding: 20px;
            border-radius: 8px;
            margin-bottom: 30px;
        }

        .summary-stats {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 15px;
            margin-top: 15px;
        }

        .stat-item {
            display: flex;
            justify-content: space-between;
            padding: 10px;
            background: white;
            border-radius: 5px;
            border-left: 4px solid #3498db;
        }

        .stat-label {
            font-weight: 600;
            color: #2c3e50;
        }

        .stat-value {
            color: #27ae60;
            font-weight: 600;
        }

        .analysis-section {
            background: white;
            padding: 25px;
            border-radius: 8px;
            border: 1px solid #e1e8ed;
            margin-bottom: 30px;
        }

        .deliverables-list {
            margin: 20px 0;
            padding-left: 0;
        }

        .deliverables-list li {
            list-style: none;
            margin: 10px 0;
            padding: 12px;
            background: #f8f9fa;
            border-radius: 5px;
            border-left: 4px solid #3498db;
        }

        .analysis-controls {
            text-align: center;
            margin-top: 25px;
        }

        .btn-primary {
            background: linear-gradient(135deg, #3498db, #2980b9);
            color: white;
            font-size: 1.1em;
            padding: 12px 30px;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            transition: transform 0.2s;
        }

        .btn-primary:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(0,0,0,0.2);
        }

        .analysis-progress {
            margin-top: 20px;
            max-width: 400px;
            margin-left: auto;
            margin-right: auto;
        }

        .analysis-results {
            background: white;
            padding: 25px;
            border-radius: 8px;
            border: 1px solid #e1e8ed;
        }

        .results-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 20px;
            margin: 20px 0;
        }

        .result-card {
            background: #f8f9fa;
            padding: 20px;
            border-radius: 8px;
            border-left: 4px solid #27ae60;
        }

        .result-card h4 {
            margin: 0 0 10px 0;
            color: #2c3e50;
        }

        .result-actions {
            margin-top: 15px;
        }

        .result-actions button {
            margin: 5px 5px 5px 0;
            padding: 6px 12px;
            font-size: 0.9em;
        }

        .completion-actions {
            text-align: center;
            margin-top: 30px;
            padding-top: 20px;
            border-top: 1px solid #e1e8ed;
        }

        .completion-actions button {
            margin: 0 10px;
        }
        
        /* Navigation Button Styles */
        .page-navigation {
            background: #f8f9fa;
            padding: 15px 20px;
            border-radius: 8px;
            margin-bottom: 20px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            flex-wrap: wrap;
            gap: 10px;
        }
        
        .nav-buttons-left {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
        }
        
        .nav-buttons-right {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
        }
        
        .btn-nav {
            background: linear-gradient(135deg, #6c757d, #5a6268);
            color: white;
            padding: 10px 20px;
            border: none;
            border-radius: 6px;
            font-size: 0.9rem;
            cursor: pointer;
            transition: all 0.2s ease;
            text-decoration: none;
            display: inline-flex;
            align-items: center;
            gap: 5px;
        }
        
        .btn-nav:hover {
            transform: translateY(-1px);
            box-shadow: 0 2px 8px rgba(0,0,0,0.2);
        }
        
        .btn-nav:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none;
        }
        
        .btn-submit {
            background: linear-gradient(135deg, #28a745, #20c997);
            color: white;
            padding: 12px 24px;
            border: none;
            border-radius: 6px;
            font-size: 1rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s ease;
        }
        
        .btn-submit:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(40, 167, 69, 0.3);
        }
        
        .error {
            background: #fff5f5;
            border: 1px solid #feb2b2;
            color: #c53030;
            padding: 16px;
            border-radius: 8px;
            margin: 16px 0;
        }
        
        .success {
            background: #f0fff4;
            border: 1px solid #9ae6b4;
            color: #22543d;
            padding: 16px;
            border-radius: 8px;
            margin: 16px 0;
        }
        
        @media (max-width: 768px) {
            .category-grid {
                grid-template-columns: 1fr;
            }
            
            .question-navigation {
                flex-direction: column;
                gap: 16px;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>🛡️ NIST CSF 2.0 Comprehensive Assessment</h1>
            <p>Complete cybersecurity framework assessment with persistent progress tracking</p>
        </div>

        <div class="progress-section">
            <div class="progress-bar">
                <div class="progress-fill" id="overallProgress"></div>
            </div>
            <div class="progress-text" id="progressText">Getting started...</div>
        </div>

        <!-- Organization Setup Screen -->
        <div class="organization-setup" id="organizationSetup">
            <h2>Organization Setup</h2>
            <div class="form-group">
                <label for="orgName">Organization Name *</label>
                <input type="text" id="orgName" placeholder="Enter your organization name" required>
            </div>
            
            <div class="form-group">
                <label for="sector">Industry Sector *</label>
                <select id="sector" required>
                    <option value="">Select your industry sector</option>
                    <option value="financial">Financial Services</option>
                    <option value="healthcare">Healthcare</option>
                    <option value="energy">Energy & Utilities</option>
                    <option value="manufacturing">Manufacturing</option>
                    <option value="technology">Technology</option>
                    <option value="government">Government</option>
                    <option value="education">Education</option>
                    <option value="retail">Retail</option>
                    <option value="transportation">Transportation</option>
                    <option value="other">Other</option>
                </select>
            </div>
            
            <div class="form-group">
                <label for="orgSize">Organization Size *</label>
                <select id="orgSize" required>
                    <option value="">Select organization size</option>
                    <option value="small">Small (1-50 employees)</option>
                    <option value="medium">Medium (51-250 employees)</option>
                    <option value="large">Large (251-1000 employees)</option>
                    <option value="enterprise">Enterprise (1000+ employees)</option>
                </select>
            </div>
            
            <div class="form-group">
                <label for="contactEmail">Contact Email</label>
                <input type="email" id="contactEmail" placeholder="contact@organization.com">
            </div>
            
            <button class="btn" onclick="startAssessment()">Start Assessment</button>
        </div>

        <!-- Category Selection Screen -->
        <!-- Function Selection Screen -->
        <div class="function-grid hidden" id="functionSelection">
            <div class="page-navigation" id="functionNavigation">
                <div class="nav-buttons-left">
                    <button class="btn-nav" id="backToCategoriesFromFunction" onclick="goBackToCategories()" style="display: none;">
                        ← Back to Categories
                    </button>
                </div>
                <div class="nav-buttons-right">
                    <button class="btn-submit" onclick="manualSubmitAssessment()">
                        📋 Submit Assessment
                    </button>
                </div>
            </div>
            <h2>Select NIST CSF 2.0 Function to Assess</h2>
            <p>Choose a cybersecurity function to begin detailed assessment</p>
            <div class="function-cards" id="functionCards">
                <!-- Functions will be populated dynamically -->
            </div>
        </div>

        <div class="category-grid hidden" id="categorySelection">
            <div class="navigation-breadcrumb">
                <span id="functionBreadcrumb"></span> → Categories
                <button onclick="showFunctionSelection()" class="breadcrumb-link">← Back to Functions</button>
            </div>
            <!-- Categories will be populated dynamically -->
        </div>

        <!-- Question Interface -->
        <div class="question-container" id="questionContainer">
            <div class="question-header">
                <div class="question-number" id="questionNumber"></div>
                <div class="question-text" id="questionText"></div>
            </div>

            <div class="question-options" id="questionOptions">
                <!-- Options populated dynamically -->
            </div>

            <div class="confidence-section">
                <label for="confidenceLevel">How confident are you in this assessment?</label>
                <select id="confidenceLevel">
                    <option value="low">Low Confidence</option>
                    <option value="medium" selected>Medium Confidence</option>
                    <option value="high">High Confidence</option>
                </select>
            </div>

            <div class="notes-section">
                <label for="notes">Additional Notes (Optional)</label>
                <textarea id="notes" placeholder="Add any additional context, concerns, or implementation details..."></textarea>
            </div>

            <div class="question-navigation">
                <div class="nav-buttons-left">
                    <button class="btn" onclick="previousQuestion()" id="prevBtn">Previous</button>
                    <button class="btn-nav" onclick="goBackToCategories()">← Back to Categories</button>
                </div>
                <div class="auto-save-indicator" id="saveIndicator">
                    <span id="saveText">Ready to save</span>
                </div>
                <button class="btn" onclick="nextQuestion()" id="nextBtn">Next Question</button>
            </div>
        </div>

        <div id="loadingIndicator" class="loading hidden">
            <div>🔄 Loading assessment data...</div>
        </div>

        <!-- Assessment Completion Screen -->
        <div class="completion-screen hidden" id="completionScreen">
            <div class="completion-header">
                <h2>🎉 Assessment Complete!</h2>
                <p>Congratulations! You have successfully completed your NIST CSF 2.0 assessment.</p>
            </div>

            <div class="completion-summary">
                <h3>Assessment Summary</h3>
                <div class="summary-stats">
                    <div class="stat-item">
                        <span class="stat-label">Organization:</span>
                        <span class="stat-value" id="completionOrgName">-</span>
                    </div>
                    <div class="stat-item">
                        <span class="stat-label">Industry:</span>
                        <span class="stat-value" id="completionSector">-</span>
                    </div>
                    <div class="stat-item">
                        <span class="stat-label">Size:</span>
                        <span class="stat-value" id="completionSize">-</span>
                    </div>
                    <div class="stat-item">
                        <span class="stat-label">Questions Answered:</span>
                        <span class="stat-value" id="completionQuestions">-</span>
                    </div>
                    <div class="stat-item">
                        <span class="stat-label">Functions Completed:</span>
                        <span class="stat-value" id="completionFunctions">6/6</span>
                    </div>
                    <div class="stat-item">
                        <span class="stat-label">Completion Date:</span>
                        <span class="stat-value" id="completionDate">-</span>
                    </div>
                </div>
            </div>

            <div class="analysis-section">
                <h3>Generate Comprehensive Analysis</h3>
                <p>Click below to generate your complete cybersecurity assessment package including:</p>
                <ul class="deliverables-list">
                    <li>📊 <strong>Maturity Assessment Report</strong> - Your organization's cybersecurity maturity tier and detailed breakdown</li>
                    <li>⚠️ <strong>Risk Analysis Report</strong> - Comprehensive risk scoring and vulnerability assessment</li>
                    <li>👔 <strong>Executive Summary</strong> - C-suite ready report with strategic recommendations</li>
                    <li>🗺️ <strong>Implementation Roadmap</strong> - Prioritized action plan with timelines</li>
                    <li>💰 <strong>Cost Estimate Analysis</strong> - Budget projections for recommended improvements</li>
                    <li>📈 <strong>Interactive Dashboard</strong> - Real-time metrics and progress tracking</li>
                    <li>📋 <strong>Gap Analysis</strong> - Detailed identification of security gaps</li>
                    <li>⭐ <strong>Priority Matrix</strong> - Risk-based prioritization of improvements</li>
                    <li>✅ <strong>Compliance Report</strong> - Multi-framework compliance status</li>
                </ul>

                <div class="analysis-controls">
                    <button class="btn btn-primary" onclick="generateComprehensiveAnalysis()" id="generateAnalysisBtn">
                        🚀 Generate Complete Analysis Package
                    </button>
                    <div class="analysis-progress hidden" id="analysisProgress">
                        <div class="progress-bar">
                            <div class="progress-fill" id="analysisProgressFill"></div>
                        </div>
                        <div class="progress-text" id="analysisProgressText">Generating analysis...</div>
                    </div>
                </div>
            </div>

            <div class="analysis-results hidden" id="analysisResults">
                <h3>📋 Your Analysis Results</h3>
                <div class="results-grid" id="resultsGrid">
                    <!-- Results will be populated dynamically -->
                </div>
                
                <div class="completion-actions">
                    <button class="btn" onclick="exportAllReports()">📥 Download All Reports</button>
                    <button class="btn" onclick="showFunctionSelection()">🔄 Review Assessment</button>
                    <button class="btn" onclick="startNewAssessment()">➕ Start New Assessment</button>
                </div>
            </div>
        </div>
    </div>

    <script>
        // VERSION CHECK - Add visual indicator that new version loaded
        document.addEventListener('DOMContentLoaded', function() {
            const versionDiv = document.createElement('div');
            versionDiv.innerHTML = '🟢 DEDUPED-CLEAN-QUESTIONS VERSION';
            versionDiv.style.cssText = 'position:fixed;top:10px;right:10px;background:green;color:white;padding:5px;border-radius:3px;z-index:9999;font-size:12px;';
            document.body.appendChild(versionDiv);
            
            // Add reset button for quick testing
            const resetBtn = document.createElement('button');
            resetBtn.innerHTML = '🔄 Reset Assessment';
            resetBtn.style.cssText = 'position:fixed;top:50px;right:10px;background:red;color:white;padding:5px;border-radius:3px;z-index:9999;font-size:12px;cursor:pointer;border:none;';
            resetBtn.onclick = function() {
                console.log('MANUAL RESET: Clearing all data');
                localStorage.clear();
                location.reload();
            };
            document.body.appendChild(resetBtn);
            
            console.log('🟢 WITHDRAWN-CONTROLS-FILTERED VERSION - Clean assessment ready');
        });

        // Global Assessment State
        let assessmentState = {
            sessionId: null,
            organizationId: null,
            profileId: null,
            workflowId: null,
            currentFunction: null,
            currentCategory: null,
            currentQuestion: 0,
            totalQuestions: 424,
            answers: new Map(),
            functions: [],
            categories: [],
            questions: [],
            functionProgress: new Map(),
            categoryProgress: new Map(),
            lastSaveTime: null
        };

        // Configuration
        const MCP_SERVER_URL = 'http://localhost:3001'; // HTTP REST API server
        const BACKUP_SAVE_DELAY = 30000; // 30 seconds backup timer for safety
        const DEBOUNCE_DELAY = 500; // 500ms debounce to prevent duplicate saves

        // Initialize Application
        document.addEventListener('DOMContentLoaded', function() {
            initializeApp();
        });

        async function initializeApp() {
            try {
                // Check for existing session
                const savedSession = localStorage.getItem('nist-csf-session');
                if (savedSession) {
                    assessmentState = { ...assessmentState, ...JSON.parse(savedSession) };
                    if (assessmentState.organizationId) {
                        await resumeExistingAssessment();
                        return;
                    }
                }
                
                // Show organization setup for new assessment
                showOrganizationSetup();
            } catch (error) {
                console.error('Initialization error:', error);
                showError('Failed to initialize assessment. Please refresh and try again.');
            }
        }

        function showOrganizationSetup() {
            // Clear any existing assessment data for fresh start
            localStorage.removeItem('nist-csf-session');
            console.log('RESET: Cleared localStorage session data');
            
            // Reset assessment state
            assessmentState.organizationId = null;
            assessmentState.profileId = null;
            assessmentState.sessionId = null;
            assessmentState.workflowId = null;
            assessmentState.currentFunction = null;
            assessmentState.currentCategory = null;
            assessmentState.currentQuestion = 0;
            assessmentState.answers = new Map();
            assessmentState.functionProgress = new Map();
            assessmentState.categoryProgress = new Map();
            console.log('RESET: Assessment state cleared');
            
            document.getElementById('organizationSetup').classList.remove('hidden');
            document.getElementById('functionSelection').classList.add('hidden');
            document.getElementById('categorySelection').classList.add('hidden');
            document.getElementById('questionContainer').style.display = 'none';
        }

        async function startAssessment() {
            try {
                showLoading(true);
                
                // Validate organization form
                const orgName = document.getElementById('orgName').value;
                const sector = document.getElementById('sector').value;
                const orgSize = document.getElementById('orgSize').value;
                const contactEmail = document.getElementById('contactEmail').value;
                
                if (!orgName || !sector || !orgSize) {
                    showError('Please fill in all required organization details.');
                    showLoading(false);
                    return;
                }

                // Create organization profile via MCP
                const profileResult = await callMCPTool('create_profile', {
                    org_name: orgName,
                    sector: sector,
                    size: orgSize,
                    profile_type: 'current',
                    profile_name: `${orgName} - Current State Assessment`,
                    description: `Comprehensive NIST CSF 2.0 assessment for ${orgName}`,
                    contact_email: contactEmail
                });

                if (!profileResult.success) {
                    throw new Error('Failed to create organization profile: ' + (profileResult.error || 'Unknown error'));
                }

                // Update assessment state - handle API response format
                const profileData = profileResult.data || profileResult;
                assessmentState.organizationId = profileData.org_id;
                assessmentState.profileId = profileData.profile_id;
                assessmentState.sessionId = generateSessionId();
                assessmentState.workflowId = `assessment-${Date.now()}`;

                // Save session to localStorage
                saveSessionState();

                // Load functions, categories and questions
                await loadFrameworkData();
                showFunctionSelection();
                
                showLoading(false);

            } catch (error) {
                console.error('Assessment start error:', error);
                showError('Failed to start assessment: ' + error.message);
                showLoading(false);
            }
        }

        async function loadFrameworkData() {
            try {
                // Get NIST CSF framework structure (functions and categories)
                const frameworkResult = await callMCPTool('csf_lookup', {});
                if (!frameworkResult.success) {
                    throw new Error('Failed to load framework structure');
                }

                // Store functions data and filter out deprecated categories
                const frameworkData = frameworkResult.data || frameworkResult;
                const rawFunctions = frameworkData.data || [];
                
                // Use a whitelist approach for valid NIST CSF 2.0 categories (excluding truly deprecated ones)
                const validCategories = new Set([
                    // GOVERN (GV) - 6 categories
                    'GV.OC', 'GV.RM', 'GV.RR', 'GV.PO', 'GV.OV', 'GV.SC',
                    // IDENTIFY (ID) - 3 categories  
                    'ID.AM', 'ID.RA', 'ID.IM',
                    // PROTECT (PR) - 5 categories
                    'PR.AA', 'PR.AT', 'PR.DS', 'PR.IR', 'PR.PS',
                    // DETECT (DE) - 3 categories
                    'DE.AE', 'DE.CM', 'DE.DP', 
                    // RESPOND (RS) - 4 categories
                    'RS.MA', 'RS.AN', 'RS.CO', 'RS.MI',
                    // RECOVER (RC) - 3 categories
                    'RC.CO', 'RC.RP', 'RC.IM'
                ]);
                
                console.log('WHITELIST FILTER: Valid NIST CSF 2.0 categories:', Array.from(validCategories).sort());
                
                assessmentState.functions = rawFunctions.map(funcItem => ({
                    ...funcItem,
                    children: funcItem.children.filter(category => {
                        const isValid = validCategories.has(category.element_identifier);
                        if (!isValid) {
                            console.log('WHITELIST FILTER: Excluding deprecated category:', category.element_identifier);
                        }
                        return isValid;
                    })
                }));
                
                console.log('FRAMEWORK FILTER: Original categories count:', 
                    rawFunctions.reduce((sum, f) => sum + f.children.length, 0));
                console.log('FRAMEWORK FILTER: Filtered categories count:', 
                    assessmentState.functions.reduce((sum, f) => sum + f.children.length, 0));
                
                // Debug category counts per function - correct NIST CSF 2.0 structure
                const expectedCounts = { GV: 6, ID: 3, PR: 5, DE: 3, RS: 4, RC: 3 };
                
                assessmentState.functions.forEach(funcItem => {
                    const func = funcItem.element;
                    const actualCount = funcItem.children.length;
                    const expectedCount = expectedCounts[func.element_identifier] || 0;
                    const status = actualCount === expectedCount ? '✅' : '❌';
                    
                    console.log(`CATEGORIES: ${status} ${func.element_identifier} (${func.title}): ${actualCount}/${expectedCount} categories:`, 
                        funcItem.children.map(c => c.element_identifier).join(', '));
                });

                // Initialize function progress tracking
                assessmentState.functions.forEach(funcItem => {
                    const func = funcItem.element;
                    assessmentState.functionProgress.set(func.element_identifier, {
                        total_categories: funcItem.children.length,
                        completed_categories: 0,
                        percentage: 0
                    });
                });

                // Get all assessment questions - Fix organization_size validation
                const orgSizeElement = document.getElementById('orgSize');
                let orgSize = orgSizeElement?.value || 'medium'; // Default fallback
                
                // Use saved organization data if available (for resume scenarios)
                const savedSession = localStorage.getItem('nist-csf-session');
                if (savedSession) {
                    try {
                        const saved = JSON.parse(savedSession);
                        if (saved.organizationData && saved.organizationData.size) {
                            orgSize = saved.organizationData.size;
                        }
                    } catch (e) {
                        console.warn('Could not parse saved organization data:', e);
                    }
                }
                
                // Validate organization size against API enum requirements
                const validSizes = ['small', 'medium', 'large', 'enterprise'];
                const validatedOrgSize = validSizes.includes(orgSize) ? orgSize : 'medium';
                
                console.log('QUESTIONS API DEBUG:');
                console.log('- orgSize element:', orgSizeElement);
                console.log('- orgSize value:', orgSize);
                console.log('- validated size:', validatedOrgSize);

                const questionsResult = await callMCPTool('get_assessment_questions', {
                    assessment_type: 'detailed',
                    organization_size: validatedOrgSize,
                    include_conditional: true,
                    include_examples: true
                });

                if (!questionsResult.success) {
                    console.error('Questions API failed:', questionsResult);
                    throw new Error(`Failed to load assessment questions: ${questionsResult.error || 'Unknown error'}`);
                }

                // Structure data by categories - handle API response format
                const questionData = questionsResult.data || questionsResult;
                const allQuestions = questionData.questions || [];
                
                // COMPREHENSIVE QUESTION FILTERING
                console.log('QUESTIONS FILTER: Starting with', allQuestions.length, 'questions');
                
                // Step 1: Filter out questions with undefined/null/empty text
                const questionsWithText = allQuestions.filter(q => {
                    const hasValidText = q.question_text && 
                                       q.question_text !== 'undefined' && 
                                       q.question_text.trim().length > 0 &&
                                       !q.question_text.includes('undefined');
                    if (!hasValidText) {
                        console.log('FILTER: Removing question with invalid text:', q.subcategory_id, '->', q.question_text);
                    }
                    return hasValidText;
                });
                
                console.log('QUESTIONS FILTER: After text filtering:', questionsWithText.length);
                
                // Step 2: Deduplicate by subcategory_id (keep first valid one)
                const seenSubcategories = new Set();
                const deduplicatedQuestions = questionsWithText.filter(q => {
                    if (seenSubcategories.has(q.subcategory_id)) {
                        console.log('FILTER: Removing duplicate subcategory:', q.subcategory_id);
                        return false;
                    }
                    seenSubcategories.add(q.subcategory_id);
                    return true;
                });
                
                console.log('QUESTIONS FILTER: After deduplication:', deduplicatedQuestions.length);
                
                // Step 3: Filter by valid NIST CSF 2.0 categories only
                const validQuestions = deduplicatedQuestions.filter(q => {
                    if (!q.subcategory_id) return false;
                    const categoryId = getCategoryFromSubcategory(q.subcategory_id);
                    return validCategories.has(categoryId);
                });
                
                console.log('QUESTIONS FILTER: Final valid questions:', validQuestions.length);
                console.log('QUESTIONS FILTER: Total filtered out:', allQuestions.length - validQuestions.length);
                
                assessmentState.questions = validQuestions;
                assessmentState.totalQuestions = validQuestions.length;
                assessmentState.categories = groupQuestionsByCategory(validQuestions);
                
                // Final verification - show categories and question quality
                console.log('FINAL VALIDATION: Generated from filtered questions:');
                const categoryStats = {};
                let totalCleanQuestions = 0;
                
                assessmentState.categories.forEach(cat => {
                    const funcId = cat.function;
                    if (!categoryStats[funcId]) categoryStats[funcId] = [];
                    categoryStats[funcId].push(cat.id);
                    totalCleanQuestions += cat.questions.length;
                    
                    // Validate no undefined questions made it through
                    const badQuestions = cat.questions.filter(q => 
                        !q.question_text || q.question_text === 'undefined' || q.question_text.includes('undefined')
                    );
                    if (badQuestions.length > 0) {
                        console.error('BAD QUESTIONS DETECTED:', cat.id, badQuestions.map(q => q.subcategory_id));
                    }
                    
                    assessmentState.categoryProgress.set(cat.id, {
                        total: cat.questions.length,
                        completed: 0,
                        percentage: 0
                    });
                });
                
                Object.keys(categoryStats).sort().forEach(funcId => {
                    console.log(`FINAL: ${funcId}: ${categoryStats[funcId].length} categories:`, categoryStats[funcId].sort().join(', '));
                });
                
                console.log('QUALITY CHECK: Total clean questions in assessment:', totalCleanQuestions);
                console.log('QUALITY CHECK: Expected NIST CSF categories with questions for assessment workflow');
                console.log('QUALITY CHECK: No undefined question text should appear in the assessment flow');

                updateOverallProgress();

            } catch (error) {
                throw new Error('Failed to load framework data: ' + error.message);
            }
        }

        function groupQuestionsByCategory(questions) {
            const categoryMap = new Map();
            
            questions.forEach(question => {
                const categoryId = getCategoryFromSubcategory(question.subcategory_id);
                
                if (!categoryMap.has(categoryId)) {
                    categoryMap.set(categoryId, {
                        id: categoryId,
                        name: getCategoryName(categoryId),
                        function: categoryId.substring(0, 2),
                        questions: []
                    });
                }
                
                categoryMap.get(categoryId).questions.push(question);
            });

            return Array.from(categoryMap.values()).sort((a, b) => a.id.localeCompare(b.id));
        }

        function getCategoryName(categoryId) {
            // Map category IDs to full names
            const categoryNames = {
                'GV.OC': 'Organizational Context',
                'GV.RM': 'Risk Management Strategy',
                'GV.RR': 'Roles, Responsibilities, and Authorities',
                'GV.PO': 'Policy',
                'GV.OV': 'Oversight',
                'GV.SC': 'Cybersecurity Supply Chain Risk Management',
                'ID.AM': 'Asset Management',
                'ID.RA': 'Risk Assessment',
                'ID.IM': 'Improvement',
                'ID.BE': 'Business Environment',
                'ID.GV': 'Governance',
                'ID.RM': 'Risk Management Strategy',
                'ID.SC': 'Supply Chain Risk Management',
                'PR.AA': 'Identity Management, Authentication, and Access Control',
                'PR.AT': 'Awareness and Training',
                'PR.DS': 'Data Security',
                'PR.PS': 'Platform Security',
                'PR.IR': 'Technology Infrastructure Resilience',
                'PR.AC': 'Identity Management, Authentication and Access Control',
                'PR.IP': 'Information Protection Processes and Procedures',
                'PR.MA': 'Maintenance',
                'PR.PT': 'Protective Technology',
                'DE.CM': 'Continuous Monitoring',
                'DE.AE': 'Adverse Event Analysis',
                'DE.DP': 'Detection Processes',
                'RS.MA': 'Incident Management',
                'RS.AN': 'Incident Analysis',
                'RS.CO': 'Incident Response Reporting and Communication',
                'RS.MI': 'Incident Mitigation',
                'RS.RP': 'Response Planning',
                'RS.IM': 'Improvements',
                'RC.RP': 'Incident Recovery Plan Execution',
                'RC.CO': 'Incident Recovery Communication',
                'RC.IM': 'Improvements'
            };
            
            return categoryNames[categoryId] || categoryId;
        }

        function showFunctionSelection() {
            document.getElementById('organizationSetup').classList.add('hidden');
            document.getElementById('functionSelection').classList.remove('hidden');
            document.getElementById('categorySelection').classList.add('hidden');
            document.getElementById('questionContainer').style.display = 'none';
            document.getElementById('completionScreen').classList.add('hidden');

            // Show/hide "Back to Categories" button based on whether a function was previously selected
            const backToCategoriesBtn = document.getElementById('backToCategoriesFromFunction');
            if (assessmentState.currentFunction && backToCategoriesBtn) {
                backToCategoriesBtn.style.display = 'inline-flex';
            } else if (backToCategoriesBtn) {
                backToCategoriesBtn.style.display = 'none';
            }

            renderFunctionCards();
        }

        function showCategorySelection() {
            document.getElementById('organizationSetup').classList.add('hidden');
            document.getElementById('functionSelection').classList.add('hidden');
            document.getElementById('categorySelection').classList.remove('hidden');
            document.getElementById('questionContainer').style.display = 'none';

            // Update breadcrumb
            const currentFuncData = assessmentState.functions.find(f => f.element.element_identifier === assessmentState.currentFunction);
            if (currentFuncData) {
                document.getElementById('functionBreadcrumb').textContent = 
                    `${currentFuncData.element.element_identifier}: ${currentFuncData.element.title}`;
            }

            renderCategoryCards();
        }

        function renderFunctionCards() {
            const container = document.getElementById('functionCards');
            container.innerHTML = '';

            assessmentState.functions.forEach(funcItem => {
                const func = funcItem.element;
                const progress = assessmentState.functionProgress.get(func.element_identifier) || { percentage: 0 };
                
                const card = document.createElement('div');
                card.className = 'function-card';
                card.onclick = () => selectFunction(func.element_identifier);
                
                card.innerHTML = `
                    <div class="function-title">${func.title}</div>
                    <div class="function-id">${func.element_identifier}</div>
                    <div class="function-description">${func.text || 'Core cybersecurity function'}</div>
                    <div class="function-stats">${funcItem.children.length} categories</div>
                    <div class="function-progress">${progress.percentage}% complete</div>
                `;
                
                container.appendChild(card);
            });
        }

        function selectFunction(functionId) {
            assessmentState.currentFunction = functionId;
            saveSessionState();
            showCategorySelection();
        }

        async function goBackToCategories() {
            // Save current answer immediately before navigation
            await saveCurrentAnswerBeforeNavigation();
            
            // Navigate back to category selection for the current function
            if (assessmentState.currentFunction) {
                showCategorySelection();
            } else {
                showError('No function selected. Please select a function first.');
            }
        }

        function manualSubmitAssessment() {
            // Allow manual submission even if assessment is not complete
            const totalAnswered = assessmentState.answers.size;
            const completionPercentage = Math.round((totalAnswered / assessmentState.totalQuestions) * 100);
            
            const message = `Are you sure you want to submit your assessment for analysis?\n\n` +
                          `Current Progress: ${completionPercentage}% complete (${totalAnswered}/${assessmentState.totalQuestions} questions answered)\n\n` +
                          `Note: You can submit with partial completion. The analysis will be based on your current responses.`;
            
            if (confirm(message)) {
                console.log('MANUAL SUBMIT: User confirmed submission with', completionPercentage, '% completion');
                showCompletionInterface();
            }
        }

        function renderCategoryCards() {
            const container = document.getElementById('categorySelection');
            
            // Preserve breadcrumb, clear only the cards area
            const breadcrumb = container.querySelector('.navigation-breadcrumb');
            container.innerHTML = '';
            if (breadcrumb) {
                container.appendChild(breadcrumb);
            }

            // Update progress for all categories before rendering
            updateAllCategoryProgress();

            // Filter categories by current function
            const filteredCategories = assessmentState.categories.filter(category => 
                category.function === assessmentState.currentFunction
            );
            
            console.log('CATEGORY FILTER:', {
                currentFunction: assessmentState.currentFunction,
                allCategories: assessmentState.categories.length,
                filteredCount: filteredCategories.length,
                filteredIds: filteredCategories.map(c => c.id)
            });

            filteredCategories.forEach(category => {
                const progress = assessmentState.categoryProgress.get(category.id) || { 
                    total: category.questions?.length || 0, 
                    completed: 0, 
                    percentage: 0 
                };
                const progressClass = progress.percentage === 100 ? 'completed' : 
                                   progress.percentage > 0 ? 'in-progress' : 'not-started';

                const card = document.createElement('div');
                card.className = `category-card ${progressClass}`;
                card.onclick = () => startCategoryAssessment(category.id);
                
                card.innerHTML = `
                    <div class="category-header">
                        <div class="category-title">${category.id}: ${category.name}</div>
                        <div class="category-progress ${progressClass}">${progress.percentage}%</div>
                    </div>
                    <div class="category-description">
                        ${progress.completed}/${progress.total} questions completed
                        <br>Function: ${category.function}
                    </div>
                `;

                container.appendChild(card);
            });
        }

        async function startCategoryAssessment(categoryId) {
            try {
                assessmentState.currentCategory = categoryId;
                const category = assessmentState.categories.find(c => c.id === categoryId);
                
                if (!category) {
                    showError('Category not found');
                    return;
                }

                // Find first unanswered question in category
                let startQuestionIndex = 0;
                for (let i = 0; i < category.questions.length; i++) {
                    if (!assessmentState.answers.has(category.questions[i].subcategory_id)) {
                        startQuestionIndex = i;
                        break;
                    }
                }

                assessmentState.currentQuestion = startQuestionIndex;
                showQuestionInterface(category);

            } catch (error) {
                console.error('Category start error:', error);
                showError('Failed to start category assessment: ' + error.message);
            }
        }

        function showQuestionInterface(category) {
            document.getElementById('categorySelection').classList.add('hidden');
            document.getElementById('questionContainer').style.display = 'block';
            
            renderCurrentQuestion(category);
        }

        function renderCurrentQuestion(category) {
            console.log('RENDER QUESTION: Starting render for category:', category.id);
            console.log('RENDER QUESTION: Question index:', assessmentState.currentQuestion);

            const question = category.questions[assessmentState.currentQuestion];
            if (!question) {
                console.log('RENDER QUESTION: No question found, category completed');
                // Category completed, return to selection
                showCategorySelection();
                return;
            }

            console.log('RENDER QUESTION: Question data:', question.subcategory_id);

            try {
                // Update question display with subcategory labeling
                const questionNumberEl = document.getElementById('questionNumber');
                const questionTextEl = document.getElementById('questionText');
                
                if (!questionNumberEl || !questionTextEl) {
                    console.error('RENDER QUESTION: Required DOM elements not found', {
                        questionNumberEl: !!questionNumberEl,
                        questionTextEl: !!questionTextEl
                    });
                    throw new Error('Required DOM elements not found');
                }
                
                questionNumberEl.textContent = `${category.id} - Question ${assessmentState.currentQuestion + 1} of ${category.questions.length}`;
                questionTextEl.textContent = `${question.subcategory_id}: ${question.question_text}`;
                
                console.log('RENDER QUESTION: Updated question display');

                // Render answer options
                console.log('RENDER QUESTION: Rendering options');
                renderQuestionOptions(question);

                // Load existing answer if available
                console.log('RENDER QUESTION: Loading existing answer');
                loadExistingAnswer(question.subcategory_id);

                // Update navigation buttons
                console.log('RENDER QUESTION: Updating navigation buttons');
                updateNavigationButtons(category);

                console.log('RENDER QUESTION: Render completed successfully');

            } catch (error) {
                console.error('RENDER QUESTION: Error during render:', error);
                throw error;
            }
        }

        function renderQuestionOptions(question) {
            const container = document.getElementById('questionOptions');
            container.innerHTML = '';

            // Use real question options if available, otherwise fallback to standard implementation levels
            const options = question.options || [
                { value: 0, label: 'Not Implemented', description: 'No measures in place' },
                { value: 1, label: 'Initial/Ad Hoc', description: 'Minimal processes, informal documentation' },
                { value: 2, label: 'Developing', description: 'Basic processes defined, some documentation' },
                { value: 3, label: 'Defined', description: 'Formal processes documented and communicated' },
                { value: 4, label: 'Managed', description: 'Processes monitored and measured for effectiveness' },
                { value: 5, label: 'Optimized', description: 'Continuous improvement with advanced automation' }
            ];

            options.forEach(option => {
                const optionDiv = document.createElement('div');
                optionDiv.className = 'option';
                
                optionDiv.innerHTML = `
                    <input type="radio" name="answer" value="${option.value}" id="option_${option.value}">
                    <label for="option_${option.value}">
                        <strong>${option.label}</strong><br>
                        <small>${option.description}</small>
                    </label>
                `;

                // Add auto-save on selection
                optionDiv.querySelector('input').addEventListener('change', function() {
                    if (this.checked) {
                        scheduleImmediateSave(question.subcategory_id, this.value);
                    }
                });

                container.appendChild(optionDiv);
            });
        }

        function loadExistingAnswer(questionId) {
            const existingAnswer = assessmentState.answers.get(questionId);
            if (existingAnswer) {
                // Select the radio button
                const radio = document.querySelector(`input[name="answer"][value="${existingAnswer.response_value}"]`);
                if (radio) radio.checked = true;

                // Load confidence and notes
                document.getElementById('confidenceLevel').value = existingAnswer.confidence_level || 'medium';
                document.getElementById('notes').value = existingAnswer.notes || '';
            }
        }

        let saveTimeout;
        let backupSaveTimeout;
        let lastSaveKey = null;
        
        async function scheduleImmediateSave(questionId, responseValue) {
            console.log('IMMEDIATE SAVE: questionId:', questionId, 'responseValue:', responseValue);
            
            // Validate parameters
            if (!questionId) {
                console.error('IMMEDIATE SAVE ERROR: questionId is null/undefined');
                return;
            }
            if (responseValue === undefined || responseValue === null) {
                console.error('IMMEDIATE SAVE ERROR: responseValue is null/undefined');
                return;
            }
            
            // Create unique key for this save to prevent duplicates
            const saveKey = `${questionId}-${responseValue}`;
            
            // Clear any pending debounced save
            if (saveTimeout) {
                clearTimeout(saveTimeout);
                console.log('IMMEDIATE SAVE: Cleared pending debounced save');
            }
            
            // Debounce rapid saves of the same answer
            if (lastSaveKey === saveKey) {
                console.log('IMMEDIATE SAVE: Debouncing duplicate save');
                return;
            }
            
            // Save immediately with debounce protection
            lastSaveKey = saveKey;
            saveTimeout = setTimeout(async () => {
                console.log('EXECUTING IMMEDIATE SAVE: questionId:', questionId, 'responseValue:', responseValue);
                await saveAnswer(questionId, responseValue);
                lastSaveKey = null; // Reset after save
            }, DEBOUNCE_DELAY);
            
            // Set backup timer in case something goes wrong
            if (backupSaveTimeout) {
                clearTimeout(backupSaveTimeout);
            }
            backupSaveTimeout = setTimeout(async () => {
                console.log('EXECUTING BACKUP SAVE: questionId:', questionId, 'responseValue:', responseValue);
                await saveAnswer(questionId, responseValue);
            }, BACKUP_SAVE_DELAY);
        }

        let isSaving = false;
        
        async function saveAnswer(questionId, responseValue) {
            try {
                // Prevent concurrent saves
                if (isSaving) {
                    console.log('SAVE: Already saving, skipping concurrent save');
                    return;
                }
                
                isSaving = true;
                showSaveIndicator('saving');

                // Validate input parameters before API call
                console.log('SAVE DEBUG: Input validation');
                console.log('- questionId (subcategory_id):', questionId);
                console.log('- responseValue:', responseValue, 'type:', typeof responseValue);
                console.log('- profileId:', assessmentState.profileId);

                if (!questionId) {
                    throw new Error('Missing questionId (subcategory_id)');
                }
                if (!assessmentState.profileId) {
                    throw new Error('Missing profile ID - please restart assessment');
                }
                if (responseValue === undefined || responseValue === null) {
                    throw new Error('Missing response value');
                }

                const answerData = {
                    subcategory_id: questionId,  // questionId is actually subcategory_id from the caller
                    response_value: parseInt(responseValue),  // Ensure numeric value for API
                    confidence_level: document.getElementById('confidenceLevel')?.value || 'medium',
                    notes: document.getElementById('notes')?.value || ''
                };

                console.log('SAVE DEBUG: Request payload:', JSON.stringify({
                    profile_id: assessmentState.profileId,
                    assessment_type: 'detailed',
                    require_all_questions: false,
                    allow_partial_responses: true,
                    responses: [answerData]
                }, null, 2));

                // Save via MCP validate_assessment_responses tool - Use only valid schema parameters
                const requestPayload = {
                    profile_id: assessmentState.profileId,
                    assessment_type: 'detailed',
                    require_all_questions: false,  // Valid schema parameter
                    validate_against_previous: false,  // Skip comparison checks for individual saves
                    check_evidence_requirements: false,  // Skip evidence checks for basic saves
                    responses: [answerData]
                };

                const result = await callMCPTool('validate_assessment_responses', requestPayload);

                // Comprehensive debugging of response structure
                console.log('DEBUG: Full API response:', JSON.stringify(result, null, 2));
                console.log('DEBUG: result.success:', result.success);
                console.log('DEBUG: result.data:', result.data);
                console.log('DEBUG: result.data.success:', result.data?.success);
                console.log('DEBUG: result.data.validation_results:', result.data?.validation_results);

                // BULLETPROOF SUCCESS CHECK: If API returns data and no errors, it's a success
                console.log('DEBUG: Full API response:', JSON.stringify(result, null, 2));
                
                // Ultra-simple success condition: API worked and returned data
                const isApiSuccess = result && result.success;
                const hasResponseData = result.data && result.data.validation_results;
                const hasZeroErrors = hasResponseData && result.data.validation_results.invalid_count === 0;
                
                console.log('ULTRA DEBUG:');
                console.log('- isApiSuccess:', isApiSuccess);
                console.log('- hasResponseData:', hasResponseData);
                console.log('- hasZeroErrors:', hasZeroErrors);
                console.log('- Final success decision:', isApiSuccess && hasZeroErrors);

                // SIMPLIFIED SUCCESS LOGIC: If API call succeeded, treat as success regardless of validation
                console.log('FINAL DECISION: API succeeded?', isApiSuccess);
                
                if (isApiSuccess) {
                    console.log('SUCCESS PATH: Saving answer locally and showing success');
                    // Update local state using subcategory_id as key
                    assessmentState.answers.set(answerData.subcategory_id, answerData);
                    assessmentState.lastSaveTime = new Date();
                    
                    // Update progress
                    updateCategoryProgress();
                    updateFunctionProgress();
                    updateOverallProgress();
                    
                    // Save session state
                    saveSessionState();
                    
                    showSaveIndicator('saved');
                } else {
                    console.error('FAILURE PATH: API call failed');
                    console.error('SAVE FAILURE ANALYSIS:');
                    console.error('- API Response Structure:', JSON.stringify(result, null, 2));
                    console.error('- Result Success:', result?.success);
                    console.error('- Result Data:', result?.data);
                    
                    const errorMsg = result.data?.error || result.error || 'API call failed - check console for details';
                    throw new Error(errorMsg);
                }

            } catch (error) {
                console.error('SAVE ERROR DETAILS:', error);
                console.error('SAVE ERROR MESSAGE:', error.message);
                console.error('SAVE ERROR STACK:', error.stack);
                showSaveIndicator('error');
                
                // Keep answer in local state even if API fails (better UX) - Fix variable scope
                const backupData = {
                    subcategory_id: questionId,  // Use function parameter
                    response_value: parseInt(responseValue),
                    confidence_level: document.getElementById('confidenceLevel').value,
                    notes: document.getElementById('notes').value
                };
                
                assessmentState.answers.set(questionId, backupData);
                updateCategoryProgress();
                updateFunctionProgress();
                updateOverallProgress();
                saveSessionState();
                
                // Keep answer in local storage as backup
                localStorage.setItem(`backup-${questionId}`, JSON.stringify({
                    subcategory_id: questionId, 
                    response_value: responseValue, 
                    timestamp: Date.now()
                }));
            } finally {
                isSaving = false;
                console.log('SAVE: Save operation completed, isSaving reset to false');
            }
        }

        function updateCategoryProgress() {
            const currentCat = assessmentState.categories.find(c => c.id === assessmentState.currentCategory);
            if (!currentCat) return;

            let completed = 0;
            currentCat.questions.forEach(q => {
                if (assessmentState.answers.has(q.subcategory_id)) completed++;
            });

            const progress = {
                total: currentCat.questions.length,
                completed: completed,
                percentage: Math.round((completed / currentCat.questions.length) * 100)
            };

            assessmentState.categoryProgress.set(assessmentState.currentCategory, progress);
        }

        function updateAllCategoryProgress() {
            // Update progress for ALL categories (for categories page display)
            assessmentState.categories.forEach(category => {
                let completed = 0;
                category.questions.forEach(q => {
                    if (assessmentState.answers.has(q.subcategory_id)) completed++;
                });

                const progress = {
                    total: category.questions.length,
                    completed: completed,
                    percentage: Math.round((completed / category.questions.length) * 100)
                };

                assessmentState.categoryProgress.set(category.id, progress);
            });
        }

        function updateFunctionProgress() {
            // Update progress for each function based on completed categories
            assessmentState.functions.forEach(funcItem => {
                const func = funcItem.element;
                const functionId = func.element_identifier;
                
                // Get categories for this function
                const functionCategories = assessmentState.categories.filter(cat => 
                    cat.function === functionId
                );
                
                // Count completed categories (100% answered)
                let completedCategories = 0;
                functionCategories.forEach(category => {
                    const categoryProgress = assessmentState.categoryProgress.get(category.id);
                    if (categoryProgress && categoryProgress.percentage === 100) {
                        completedCategories++;
                    }
                });
                
                // Calculate function progress percentage
                const totalCategories = functionCategories.length;
                const functionPercentage = totalCategories > 0 ? 
                    Math.round((completedCategories / totalCategories) * 100) : 0;
                
                // Update function progress
                assessmentState.functionProgress.set(functionId, {
                    total_categories: totalCategories,
                    completed_categories: completedCategories,
                    percentage: functionPercentage
                });
                
                console.log(`FUNCTION PROGRESS UPDATE: ${functionId} = ${completedCategories}/${totalCategories} = ${functionPercentage}%`);
            });
            
            // Check if assessment is complete after updating function progress
            checkAssessmentCompletion();
        }

        function updateOverallProgress() {
            const totalAnswered = assessmentState.answers.size;
            const percentage = Math.round((totalAnswered / assessmentState.totalQuestions) * 100);
            
            document.getElementById('overallProgress').style.width = percentage + '%';
            document.getElementById('progressText').textContent = 
                `${percentage}% Complete - ${totalAnswered}/${assessmentState.totalQuestions} Questions Answered`;
        }

        function checkAssessmentCompletion() {
            console.log('COMPLETION CHECK: Starting assessment completion check');
            
            // Check if all functions have 100% completion
            let totalFunctions = 0;
            let completedFunctions = 0;
            
            assessmentState.functions.forEach(funcItem => {
                const func = funcItem.element;
                const progress = assessmentState.functionProgress.get(func.element_identifier);
                if (progress) {
                    totalFunctions++;
                    if (progress.percentage === 100) {
                        completedFunctions++;
                    }
                    console.log(`COMPLETION CHECK: ${func.element_identifier} = ${progress.percentage}%`);
                }
            });
            
            const isComplete = completedFunctions === totalFunctions && totalFunctions > 0;
            console.log(`COMPLETION CHECK: ${completedFunctions}/${totalFunctions} functions complete. Overall complete: ${isComplete}`);
            
            if (isComplete) {
                console.log('COMPLETION CHECK: Assessment is complete! Showing completion interface.');
                showCompletionInterface();
            }
            
            return isComplete;
        }

        function showCompletionInterface() {
            console.log('COMPLETION INTERFACE: Preparing completion screen');
            
            // Hide all other screens
            document.getElementById('organizationSetup').classList.add('hidden');
            document.getElementById('functionSelection').classList.add('hidden');
            document.getElementById('categorySelection').classList.add('hidden');
            document.getElementById('questionContainer').style.display = 'none';
            
            // Show completion screen
            document.getElementById('completionScreen').classList.remove('hidden');
            
            // Populate completion summary
            populateCompletionSummary();
            
            console.log('COMPLETION INTERFACE: Completion screen displayed');
        }

        function populateCompletionSummary() {
            // Get organization data from localStorage
            const savedSession = localStorage.getItem('nist-csf-session');
            let orgData = { name: '', sector: '', size: '' };
            
            if (savedSession) {
                try {
                    const session = JSON.parse(savedSession);
                    if (session.organizationData) {
                        orgData = session.organizationData;
                    }
                } catch (e) {
                    console.warn('Could not parse saved session data:', e);
                }
            }
            
            // Also try to get from form elements if still available
            const orgNameEl = document.getElementById('orgName');
            const orgSectorEl = document.getElementById('sector');
            const orgSizeEl = document.getElementById('orgSize');
            
            if (orgNameEl && orgNameEl.value) orgData.name = orgNameEl.value;
            if (orgSectorEl && orgSectorEl.value) orgData.sector = orgSectorEl.value;
            if (orgSizeEl && orgSizeEl.value) orgData.size = orgSizeEl.value;
            
            // Populate completion summary
            document.getElementById('completionOrgName').textContent = orgData.name || 'Organization';
            document.getElementById('completionSector').textContent = 
                orgData.sector ? orgData.sector.charAt(0).toUpperCase() + orgData.sector.slice(1) : 'Not specified';
            document.getElementById('completionSize').textContent = 
                orgData.size ? orgData.size.charAt(0).toUpperCase() + orgData.size.slice(1) : 'Not specified';
            document.getElementById('completionQuestions').textContent = 
                `${assessmentState.answers.size}/${assessmentState.totalQuestions}`;
            document.getElementById('completionDate').textContent = 
                new Date().toLocaleDateString('en-US', { 
                    year: 'numeric', 
                    month: 'long', 
                    day: 'numeric' 
                });
        }

        function showSaveIndicator(status) {
            const indicator = document.getElementById('saveIndicator');
            const text = document.getElementById('saveText');
            
            indicator.className = `auto-save-indicator ${status}`;
            
            switch(status) {
                case 'saving':
                    text.textContent = '💾 Saving...';
                    break;
                case 'saved':
                    text.textContent = '✅ Saved';
                    setTimeout(() => {
                        text.textContent = 'Auto-save enabled';
                        indicator.className = 'auto-save-indicator';
                    }, 2000);
                    break;
                case 'error':
                    text.textContent = '❌ Save failed - stored locally (check console F12)';
                    break;
                default:
                    text.textContent = 'Auto-save enabled';
            }
        }

        function saveSessionState() {
            // Capture organization form data for resume functionality
            const orgSizeElement = document.getElementById('orgSize');
            const orgNameElement = document.getElementById('orgName');
            const orgSectorElement = document.getElementById('orgSector');
            
            const sessionData = {
                sessionId: assessmentState.sessionId,
                organizationId: assessmentState.organizationId,
                profileId: assessmentState.profileId,
                workflowId: assessmentState.workflowId,
                currentFunction: assessmentState.currentFunction,
                currentCategory: assessmentState.currentCategory,
                currentQuestion: assessmentState.currentQuestion,
                answers: Array.from(assessmentState.answers.entries()),
                functionProgress: Array.from(assessmentState.functionProgress.entries()),
                categoryProgress: Array.from(assessmentState.categoryProgress.entries()),
                lastSaveTime: assessmentState.lastSaveTime,
                // Save organization form data for API calls during resume
                organizationData: {
                    size: orgSizeElement?.value || 'medium',
                    name: orgNameElement?.value || '',
                    sector: orgSectorElement?.value || ''
                }
            };
            
            localStorage.setItem('nist-csf-session', JSON.stringify(sessionData));
        }

        async function resumeExistingAssessment() {
            try {
                showLoading(true);
                
                // Restore state from localStorage
                const saved = JSON.parse(localStorage.getItem('nist-csf-session'));
                assessmentState.answers = new Map(saved.answers || []);
                assessmentState.functionProgress = new Map(saved.functionProgress || []);
                assessmentState.categoryProgress = new Map(saved.categoryProgress || []);
                assessmentState.currentFunction = saved.currentFunction;
                
                // Restore organization form data if available
                if (saved.organizationData) {
                    const orgSizeElement = document.getElementById('orgSize');
                    const orgNameElement = document.getElementById('orgName');
                    const orgSectorElement = document.getElementById('orgSector');
                    
                    if (orgSizeElement && saved.organizationData.size) {
                        orgSizeElement.value = saved.organizationData.size;
                    }
                    if (orgNameElement && saved.organizationData.name) {
                        orgNameElement.value = saved.organizationData.name;
                    }
                    if (orgSectorElement && saved.organizationData.sector) {
                        orgSectorElement.value = saved.organizationData.sector;
                    }
                }
                
                // Load framework data
                await loadFrameworkData();
                
                // Navigate to appropriate screen based on saved state
                if (assessmentState.currentFunction) {
                    if (assessmentState.currentCategory) {
                        // Resume in category
                        showCategorySelection();
                    } else {
                        // Resume at category selection for function
                        showCategorySelection();
                    }
                } else {
                    // Resume at function selection
                    showFunctionSelection();
                }
                updateOverallProgress();
                
                showSuccess(`Welcome back! Resuming assessment for organization ID: ${assessmentState.organizationId}`);
                showLoading(false);

            } catch (error) {
                console.error('Resume error:', error);
                console.error('Resume error details:', error.message);
                console.error('Resume error stack:', error.stack);
                showError(`Failed to resume assessment: ${error.message}. Starting fresh...`);
                localStorage.removeItem('nist-csf-session');
                showOrganizationSetup();
                showLoading(false);
            }
        }

        let nextButtonClickCount = 0;
        
        async function saveCurrentAnswerBeforeNavigation() {
            const currentQuestion = getCurrentQuestion();
            if (!currentQuestion) return;
            
            const selectedAnswer = document.querySelector('input[name="answer"]:checked');
            if (selectedAnswer) {
                console.log('NAVIGATION SAVE: Saving current answer before navigation');
                await saveAnswer(currentQuestion.subcategory_id, selectedAnswer.value);
            }
        }
        
        function getCurrentQuestion() {
            const currentCat = assessmentState.categories.find(c => c.id === assessmentState.currentCategory);
            if (!currentCat || !currentCat.questions[assessmentState.currentQuestion]) return null;
            return currentCat.questions[assessmentState.currentQuestion];
        }

        async function nextQuestion() {
            nextButtonClickCount++;
            console.log('NEXT QUESTION: Button clicked - Count:', nextButtonClickCount);
            
            // Update click counter display
            const clickCounter = document.getElementById('clickCounter');
            if (clickCounter) {
                clickCounter.innerHTML = `Next Button Clicks: ${nextButtonClickCount}`;
            }
            
            // Prevent multiple rapid clicks
            const nextBtn = document.getElementById('nextBtn');
            if (nextBtn.disabled) {
                console.log('NEXT QUESTION: Button already disabled, ignoring click');
                return;
            }
            
            // Disable button temporarily
            nextBtn.disabled = true;
            nextBtn.style.opacity = '0.6';
            
            console.log('NEXT QUESTION: Current state:', {
                currentCategory: assessmentState.currentCategory,
                currentQuestion: assessmentState.currentQuestion,
                totalCategories: assessmentState.categories.length
            });

            const currentCat = assessmentState.categories.find(c => c.id === assessmentState.currentCategory);
            if (!currentCat) {
                console.error('NEXT QUESTION: Current category not found');
                nextBtn.disabled = false;
                nextBtn.style.opacity = '1';
                return;
            }

            console.log('NEXT QUESTION: Current category:', currentCat.id, 'Total questions:', currentCat.questions.length);

            // Save current answer immediately before navigation
            await saveCurrentAnswerBeforeNavigation();

            // Clear any pending saves
            if (saveTimeout) {
                console.log('NEXT QUESTION: Clearing pending save');
                clearTimeout(saveTimeout);
                saveTimeout = null;
            }
            if (backupSaveTimeout) {
                clearTimeout(backupSaveTimeout);
                backupSaveTimeout = null;
            }

            if (assessmentState.currentQuestion < currentCat.questions.length - 1) {
                console.log('NEXT QUESTION: Advancing from', assessmentState.currentQuestion, 'to', assessmentState.currentQuestion + 1);
                assessmentState.currentQuestion++;
                
                try {
                    renderCurrentQuestion(currentCat);
                    console.log('NEXT QUESTION: Successfully rendered question', assessmentState.currentQuestion);
                    // Reset click counter on successful navigation
                    nextButtonClickCount = 0;
                    if (clickCounter) {
                        clickCounter.innerHTML = `Next Button Clicks: ${nextButtonClickCount}`;
                    }
                } catch (error) {
                    console.error('NEXT QUESTION: Error rendering question:', error);
                }
            } else {
                console.log('NEXT QUESTION: Category completed, returning to selection');
                // Category completed, return to selection
                showCategorySelection();
            }

            // Re-enable button after short delay
            setTimeout(() => {
                nextBtn.disabled = false;
                nextBtn.style.opacity = '1';
                console.log('NEXT QUESTION: Button re-enabled');
            }, 100);
        }

        async function previousQuestion() {
            const currentCat = assessmentState.categories.find(c => c.id === assessmentState.currentCategory);
            if (!currentCat) return;

            // Save current answer immediately before navigation
            await saveCurrentAnswerBeforeNavigation();

            if (assessmentState.currentQuestion > 0) {
                assessmentState.currentQuestion--;
                renderCurrentQuestion(currentCat);
            } else {
                // Return to category selection
                showCategorySelection();
            }
        }

        function updateNavigationButtons(category) {
            const prevBtn = document.getElementById('prevBtn');
            const nextBtn = document.getElementById('nextBtn');
            
            prevBtn.style.display = assessmentState.currentQuestion > 0 ? 'block' : 'none';
            
            if (assessmentState.currentQuestion === category.questions.length - 1) {
                nextBtn.textContent = 'Back to Categories';
            } else {
                nextBtn.textContent = 'Next Question';
            }
        }

        // Utility Functions
        function generateSessionId() {
            return 'session-' + Date.now() + '-' + Math.random().toString(36).substr(2, 9);
        }

        async function callMCPTool(toolName, params, maxRetries = 3) {
            let lastError;
            
            for (let attempt = 1; attempt <= maxRetries; attempt++) {
                try {
                    console.log(`Calling MCP tool: ${toolName} (attempt ${attempt}/${maxRetries})`, params);
                    
                    const response = await fetch(`${MCP_SERVER_URL}/api/tools/${toolName}`, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                            'Accept': 'application/json'
                        },
                        body: JSON.stringify(params)
                    });

                    // Handle rate limiting with exponential backoff
                    if (response.status === 429) {
                        const retryAfter = response.headers.get('Retry-After');
                        const delay = retryAfter ? parseInt(retryAfter) * 1000 : Math.pow(2, attempt) * 1000;
                        
                        console.warn(`Rate limited (429) on attempt ${attempt}. Retrying after ${delay}ms...`);
                        
                        if (attempt < maxRetries) {
                            await new Promise(resolve => setTimeout(resolve, delay));
                            continue; // Retry
                        } else {
                            throw new Error(`Rate limit exceeded. Please try again in ${Math.ceil(delay/1000)} seconds.`);
                        }
                    }

                    if (!response.ok) {
                        throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                    }

                    const result = await response.json();
                    console.log(`MCP tool result (attempt ${attempt}):`, result);
                    
                    return result;

                } catch (error) {
                    lastError = error;
                    console.error(`MCP tool error (${toolName}) attempt ${attempt}:`, error);
                    
                    // If it's not a rate limit error and not the last attempt, wait before retry
                    if (attempt < maxRetries && !error.message.includes('Rate limit')) {
                        const delay = Math.pow(2, attempt) * 500; // 500ms, 1s, 2s
                        console.log(`Retrying after ${delay}ms...`);
                        await new Promise(resolve => setTimeout(resolve, delay));
                    }
                }
            }
            
            // All retries exhausted
            return { 
                success: false, 
                error: `Failed to call ${toolName} after ${maxRetries} attempts: ${lastError.message}` 
            };
        }

        async function generateComprehensiveAnalysis() {
            try {
                console.log('ANALYSIS GENERATION: Starting comprehensive analysis generation');
                
                // Show progress and disable button
                document.getElementById('generateAnalysisBtn').disabled = true;
                document.getElementById('analysisProgress').classList.remove('hidden');
                
                const progressBar = document.getElementById('analysisProgressFill');
                const progressText = document.getElementById('analysisProgressText');
                
                const results = {};
                let stepIndex = 0;
                const totalSteps = 8;
                
                // Helper function to update progress
                const updateProgress = (stepName) => {
                    stepIndex++;
                    const progress = Math.round((stepIndex / totalSteps) * 100);
                    progressBar.style.width = progress + '%';
                    progressText.textContent = `Generating ${stepName}... (${progress}%)`;
                    console.log(`ANALYSIS GENERATION: Step ${stepIndex}/${totalSteps}: ${stepName}`);
                };
                
                // Step 1: Maturity Assessment
                updateProgress('Maturity Assessment');
                try {
                    const maturityResult = await callMCPTool('assess_maturity', { 
                        profile_id: assessmentState.profileId, 
                        include_recommendations: true 
                    });
                    results['assess_maturity'] = maturityResult.success ? maturityResult.data : { error: maturityResult.error };
                } catch (error) {
                    console.error('ANALYSIS: Maturity assessment error:', error);
                    results['assess_maturity'] = { error: error.message };
                }
                await new Promise(resolve => setTimeout(resolve, 500));
                
                // Step 2: Risk Analysis  
                updateProgress('Risk Analysis');
                try {
                    const riskResult = await callMCPTool('calculate_risk_score', { 
                        profile_id: assessmentState.profileId 
                    });
                    results['calculate_risk_score'] = riskResult.success ? riskResult.data : { error: riskResult.error };
                } catch (error) {
                    console.error('ANALYSIS: Risk analysis error:', error);
                    results['calculate_risk_score'] = { error: error.message };
                }
                await new Promise(resolve => setTimeout(resolve, 500));
                
                // Step 3: Gap Analysis (using profile as both current and target for self-assessment)
                updateProgress('Gap Analysis');
                try {
                    const gapResult = await callMCPTool('generate_gap_analysis', { 
                        current_profile_id: assessmentState.profileId,
                        target_profile_id: assessmentState.profileId
                    });
                    results['generate_gap_analysis'] = gapResult.success ? gapResult.data : { error: gapResult.error };
                } catch (error) {
                    console.error('ANALYSIS: Gap analysis error:', error);
                    results['generate_gap_analysis'] = { error: error.message };
                }
                await new Promise(resolve => setTimeout(resolve, 500));
                
                // Step 4: Priority Matrix
                updateProgress('Priority Matrix');
                try {
                    const priorityResult = await callMCPTool('generate_priority_matrix', { 
                        profile_id: assessmentState.profileId 
                    });
                    results['generate_priority_matrix'] = priorityResult.success ? priorityResult.data : { error: priorityResult.error };
                } catch (error) {
                    console.error('ANALYSIS: Priority matrix error:', error);
                    results['generate_priority_matrix'] = { error: error.message };
                }
                await new Promise(resolve => setTimeout(resolve, 500));
                
                // Step 5: Cost Estimates (extract subcategory IDs from answered questions)
                updateProgress('Cost Estimates');
                try {
                    // Get subcategory IDs from answered questions
                    const subcategoryIds = Array.from(assessmentState.answers.keys()).map(key => {
                        // Extract subcategory ID from question key (format: "subcategory_id-question_type")
                        return key.split('-')[0];
                    }).filter((id, index, arr) => arr.indexOf(id) === index); // Remove duplicates
                    
                    // Get organization size from localStorage or default
                    const orgData = JSON.parse(localStorage.getItem('nist-csf-session') || '{}');
                    const orgSize = document.getElementById('orgSize')?.value || 'medium'; // Fallback to medium
                    
                    const costResult = await callMCPTool('estimate_implementation_cost', { 
                        subcategory_ids: subcategoryIds.slice(0, 20), // Limit to first 20 to avoid API limits
                        organization_size: orgSize
                    });
                    results['estimate_implementation_cost'] = costResult.success ? costResult.data : { error: costResult.error };
                } catch (error) {
                    console.error('ANALYSIS: Cost estimates error:', error);
                    results['estimate_implementation_cost'] = { error: error.message };
                }
                await new Promise(resolve => setTimeout(resolve, 500));
                
                // Step 6: Implementation Plan (use gap analysis ID if available)
                updateProgress('Implementation Plan');
                try {
                    const gapAnalysisId = results['generate_gap_analysis']?.id || assessmentState.profileId;
                    const planResult = await callMCPTool('create_implementation_plan', { 
                        gap_analysis_id: gapAnalysisId,
                        timeline_months: 12,
                        available_resources: 'medium'
                    });
                    results['create_implementation_plan'] = planResult.success ? planResult.data : { error: planResult.error };
                } catch (error) {
                    console.error('ANALYSIS: Implementation plan error:', error);
                    results['create_implementation_plan'] = { error: error.message };
                }
                await new Promise(resolve => setTimeout(resolve, 500));
                
                // Step 7: Executive Report
                updateProgress('Executive Report');
                try {
                    const execResult = await callMCPTool('generate_report', { 
                        profile_id: assessmentState.profileId,
                        report_type: 'executive'
                    });
                    results['generate_executive_report'] = execResult.success ? execResult.data : { error: execResult.error };
                } catch (error) {
                    console.error('ANALYSIS: Executive report error:', error);
                    results['generate_executive_report'] = { error: error.message };
                }
                await new Promise(resolve => setTimeout(resolve, 500));
                
                // Step 8: Dashboard Report  
                updateProgress('Dashboard');
                try {
                    const dashResult = await callMCPTool('generate_report', { 
                        profile_id: assessmentState.profileId,
                        report_type: 'dashboard'
                    });
                    results['generate_dashboard'] = dashResult.success ? dashResult.data : { error: dashResult.error };
                } catch (error) {
                    console.error('ANALYSIS: Dashboard error:', error);
                    results['generate_dashboard'] = { error: error.message };
                }
                
                progressText.textContent = '100% Complete - Analysis generated!';
                
                // Display results
                displayAnalysisResults(results);
                
                console.log('ANALYSIS GENERATION: All analysis completed');
                
            } catch (error) {
                console.error('ANALYSIS GENERATION: Failed:', error);
                showError('Failed to generate analysis: ' + error.message);
            }
        }

        function displayAnalysisResults(results) {
            const resultsContainer = document.getElementById('analysisResults');
            const resultsGrid = document.getElementById('resultsGrid');
            
            // Clear previous results
            resultsGrid.innerHTML = '';
            
            const reportDefinitions = [
                { key: 'assess_maturity', title: '📊 Maturity Assessment', description: 'Your cybersecurity maturity tier and detailed breakdown' },
                { key: 'calculate_risk_score', title: '⚠️ Risk Analysis', description: 'Comprehensive risk scoring and vulnerability assessment' },
                { key: 'generate_gap_analysis', title: '📋 Gap Analysis', description: 'Detailed identification of security gaps' },
                { key: 'generate_priority_matrix', title: '⭐ Priority Matrix', description: 'Risk-based prioritization of improvements' },
                { key: 'create_implementation_plan', title: '🗺️ Implementation Roadmap', description: 'Prioritized action plan with timelines' },
                { key: 'estimate_implementation_cost', title: '💰 Cost Estimates', description: 'Budget projections for recommended improvements' },
                { key: 'generate_executive_report', title: '👔 Executive Report', description: 'C-suite ready report with strategic recommendations' },
                { key: 'generate_dashboard', title: '📈 Dashboard', description: 'Real-time metrics and progress tracking' }
            ];
            
            reportDefinitions.forEach(report => {
                const result = results[report.key];
                const card = document.createElement('div');
                card.className = 'result-card';
                
                const status = result && !result.error ? '✅ Generated' : '❌ Failed';
                const statusClass = result && !result.error ? 'success' : 'error';
                
                card.innerHTML = `
                    <h4>${report.title}</h4>
                    <p>${report.description}</p>
                    <div class="result-status ${statusClass}">${status}</div>
                    <div class="result-actions">
                        ${result && !result.error ? 
                            `<button class="btn" onclick="viewReport('${report.key}')">👁️ View</button>
                             <button class="btn" onclick="downloadReport('${report.key}')">📥 Download</button>` :
                            `<span class="error-text">Error: ${result?.error || 'Unknown error'}</span>`
                        }
                    </div>
                `;
                
                resultsGrid.appendChild(card);
            });
            
            // Store results globally for access by view/download functions
            window.analysisResults = results;
            
            // Show results section
            resultsContainer.classList.remove('hidden');
        }

        function viewReport(reportKey) {
            const result = window.analysisResults?.[reportKey];
            if (result) {
                // Create a popup window to display the report
                const reportWindow = window.open('', '_blank', 'width=800,height=600,scrollbars=yes');
                reportWindow.document.write(`
                    <html>
                    <head>
                        <title>NIST CSF 2.0 Analysis Report</title>
                        <style>
                            body { font-family: Arial, sans-serif; margin: 20px; line-height: 1.6; }
                            h1, h2, h3 { color: #2c3e50; }
                            pre { background: #f8f9fa; padding: 15px; border-radius: 5px; overflow: auto; }
                            .report-header { background: #3498db; color: white; padding: 15px; border-radius: 5px; margin-bottom: 20px; }
                        </style>
                    </head>
                    <body>
                        <div class="report-header">
                            <h1>NIST CSF 2.0 Assessment Report</h1>
                            <p>Generated: ${new Date().toLocaleString()}</p>
                        </div>
                        <pre>${JSON.stringify(result, null, 2)}</pre>
                    </body>
                    </html>
                `);
                reportWindow.document.close();
            }
        }

        function downloadReport(reportKey) {
            const result = window.analysisResults?.[reportKey];
            if (!result) {
                showError('No report data available for download');
                return;
            }
            
            // Create formatted HTML for PDF generation
            const reportTitle = getReportTitle(reportKey);
            const reportDate = new Date().toISOString().split('T')[0];
            const orgName = assessmentState.organizationName || 'Organization';
            
            const htmlContent = `
                <!DOCTYPE html>
                <html>
                <head>
                    <meta charset="UTF-8">
                    <title>${reportTitle} - ${orgName}</title>
                    <style>
                        @page { margin: 1in; size: letter; }
                        body { font-family: Arial, sans-serif; line-height: 1.4; color: #333; }
                        .header { border-bottom: 2px solid #2c5aa0; padding-bottom: 20px; margin-bottom: 30px; }
                        .header h1 { color: #2c5aa0; margin: 0; font-size: 24px; }
                        .header .meta { color: #666; margin-top: 10px; }
                        .section { margin-bottom: 30px; page-break-inside: avoid; }
                        .section h2 { color: #2c5aa0; border-bottom: 1px solid #ddd; padding-bottom: 5px; }
                        .section h3 { color: #444; margin-top: 20px; }
                        .data-table { width: 100%; border-collapse: collapse; margin: 15px 0; }
                        .data-table th, .data-table td { border: 1px solid #ddd; padding: 8px; text-align: left; }
                        .data-table th { background-color: #f5f5f5; font-weight: bold; }
                        .score-high { color: #28a745; font-weight: bold; }
                        .score-medium { color: #ffc107; font-weight: bold; }
                        .score-low { color: #dc3545; font-weight: bold; }
                        .json-data { background: #f8f9fa; border: 1px solid #ddd; padding: 15px; 
                                    border-radius: 4px; font-family: monospace; font-size: 12px; 
                                    white-space: pre-wrap; word-wrap: break-word; }
                        .footer { margin-top: 50px; padding-top: 20px; border-top: 1px solid #ddd; 
                                 font-size: 12px; color: #666; text-align: center; }
                    </style>
                </head>
                <body>
                    <div class="header">
                        <h1>${reportTitle}</h1>
                        <div class="meta">
                            <strong>Organization:</strong> ${orgName}<br>
                            <strong>Report Date:</strong> ${reportDate}<br>
                            <strong>Profile ID:</strong> ${assessmentState.profileId || 'N/A'}
                        </div>
                    </div>
                    
                    ${formatReportContent(reportKey, result)}
                    
                    <div class="footer">
                        Generated by NIST CSF 2.0 Assessment Platform | ${new Date().toLocaleString()}
                    </div>
                </body>
                </html>
            `;
            
            // Create and trigger PDF download
            const printWindow = window.open('', '_blank');
            printWindow.document.write(htmlContent);
            printWindow.document.close();
            
            // Wait for content to load, then trigger print dialog
            printWindow.onload = function() {
                setTimeout(function() {
                    printWindow.print();
                    // Close the window after a delay (user may cancel print dialog)
                    setTimeout(() => printWindow.close(), 1000);
                }, 500);
            };
        }
        
        function getReportTitle(reportKey) {
            const titles = {
                'assess_maturity': 'NIST CSF 2.0 Maturity Assessment Report',
                'calculate_risk_score': 'Cybersecurity Risk Analysis Report', 
                'generate_gap_analysis': 'Security Gap Analysis Report',
                'generate_priority_matrix': 'Implementation Priority Matrix',
                'create_implementation_plan': 'Cybersecurity Implementation Roadmap',
                'estimate_implementation_cost': 'Implementation Cost Analysis',
                'generate_executive_report': 'Executive Cybersecurity Report',
                'generate_dashboard': 'Cybersecurity Dashboard Report'
            };
            return titles[reportKey] || 'NIST CSF 2.0 Analysis Report';
        }
        
        function formatReportContent(reportKey, result) {
            // Handle specific report types with custom formatting
            if (reportKey === 'assess_maturity') {
                return formatMaturityReport(result);
            } else if (reportKey === 'calculate_risk_score') {
                return formatRiskReport(result);
            } else if (reportKey === 'generate_gap_analysis') {
                return formatGapAnalysisReport(result);
            } else {
                // Generic formatting for other report types
                return `
                    <div class="section">
                        <h2>Report Summary</h2>
                        <p><strong>Success:</strong> ${result.success ? 'Yes' : 'No'}</p>
                        ${result.error ? `<p><strong>Error:</strong> ${result.error}</p>` : ''}
                    </div>
                    
                    <div class="section">
                        <h2>Detailed Data</h2>
                        <div class="json-data">${JSON.stringify(result, null, 2)}</div>
                    </div>
                `;
            }
        }
        
        function formatMaturityReport(result) {
            return `
                <div class="section">
                    <h2>Maturity Assessment Summary</h2>
                    <table class="data-table">
                        <tr><th>Overall Maturity Tier</th><td class="score-medium">${result.overall_maturity_tier || 'Unknown'}</td></tr>
                        <tr><th>Overall Maturity Score</th><td>${result.overall_maturity_score || 0}</td></tr>
                        <tr><th>Implementation Percentage</th><td>${result.statistics?.overall_implementation_percentage || 0}%</td></tr>
                        <tr><th>Assessment Date</th><td>${result.assessment_date || 'N/A'}</td></tr>
                    </table>
                </div>
                
                <div class="section">
                    <h2>Function Breakdown</h2>
                    ${result.function_breakdown && result.function_breakdown.length > 0 ? 
                        `<table class="data-table">
                            <tr><th>Function</th><th>Score</th><th>Tier</th><th>Categories</th></tr>
                            ${result.function_breakdown.map(func => 
                                `<tr>
                                    <td><strong>${func.function_name}</strong></td>
                                    <td>${func.function_score || 0}</td>
                                    <td class="score-medium">${func.maturity_tier || 'Unknown'}</td>
                                    <td>${func.categories ? func.categories.length : 0}</td>
                                </tr>`
                            ).join('')}
                        </table>` : 
                        '<p>No function data available. Please complete the assessment first.</p>'
                    }
                </div>
                
                <div class="section">
                    <h2>Statistics</h2>
                    <table class="data-table">
                        <tr><th>Total Functions Assessed</th><td>${result.statistics?.total_functions || 0}</td></tr>
                        <tr><th>Functions at Adaptive Level</th><td class="score-high">${result.statistics?.functions_at_adaptive || 0}</td></tr>
                        <tr><th>Functions at Repeatable Level</th><td class="score-medium">${result.statistics?.functions_at_repeatable || 0}</td></tr>
                        <tr><th>Functions at Risk-Informed Level</th><td class="score-medium">${result.statistics?.functions_at_risk_informed || 0}</td></tr>
                        <tr><th>Functions at Partial Level</th><td class="score-low">${result.statistics?.functions_at_partial || 0}</td></tr>
                        <tr><th>Strongest Function</th><td>${result.statistics?.strongest_function || 'N/A'}</td></tr>
                        <tr><th>Weakest Function</th><td>${result.statistics?.weakest_function || 'N/A'}</td></tr>
                    </table>
                </div>
            `;
        }
        
        function formatRiskReport(result) {
            return `
                <div class="section">
                    <h2>Risk Assessment Summary</h2>
                    <table class="data-table">
                        <tr><th>Overall Risk Score</th><td class="${result.overall_risk_score > 7 ? 'score-low' : result.overall_risk_score > 4 ? 'score-medium' : 'score-high'}">${result.overall_risk_score || 'N/A'}</td></tr>
                        <tr><th>Risk Level</th><td>${result.risk_level || 'Unknown'}</td></tr>
                        <tr><th>Assessment Date</th><td>${result.assessment_date || 'N/A'}</td></tr>
                    </table>
                </div>
                
                <div class="section">
                    <h2>Detailed Risk Analysis</h2>
                    <div class="json-data">${JSON.stringify(result, null, 2)}</div>
                </div>
            `;
        }
        
        function formatGapAnalysisReport(result) {
            return `
                <div class="section">
                    <h2>Gap Analysis Summary</h2>
                    <p>This report identifies security gaps and areas for improvement in your cybersecurity posture.</p>
                </div>
                
                <div class="section">
                    <h2>Detailed Gap Analysis</h2>
                    <div class="json-data">${JSON.stringify(result, null, 2)}</div>
                </div>
            `;
        }

        function exportAllReports() {
            if (window.analysisResults) {
                const allReports = {
                    organization: {
                        name: document.getElementById('completionOrgName').textContent,
                        sector: document.getElementById('completionSector').textContent,
                        size: document.getElementById('completionSize').textContent
                    },
                    assessment: {
                        completed_date: document.getElementById('completionDate').textContent,
                        questions_answered: document.getElementById('completionQuestions').textContent,
                        functions_completed: document.getElementById('completionFunctions').textContent
                    },
                    reports: window.analysisResults
                };
                
                const dataStr = JSON.stringify(allReports, null, 2);
                const dataBlob = new Blob([dataStr], {type: 'application/json'});
                
                const link = document.createElement('a');
                link.href = URL.createObjectURL(dataBlob);
                link.download = `nist-csf-complete-analysis-${new Date().toISOString().split('T')[0]}.json`;
                link.click();
            }
        }

        function startNewAssessment() {
            if (confirm('Are you sure you want to start a new assessment? This will clear all current data.')) {
                localStorage.clear();
                location.reload();
            }
        }

        // Utility function to extract category from subcategory ID
        function getCategoryFromSubcategory(subcategoryId) {
            // Extract category (e.g., "GV.OC" from "GV.OC-01")
            return subcategoryId.split('-')[0];
        }

        function showLoading(show) {
            const indicator = document.getElementById('loadingIndicator');
            if (show) {
                indicator.classList.remove('hidden');
            } else {
                indicator.classList.add('hidden');
            }
        }

        function showError(message) {
            // Create and show error message
            const errorDiv = document.createElement('div');
            errorDiv.className = 'error';
            errorDiv.textContent = message;
            
            document.querySelector('.container').insertBefore(errorDiv, document.querySelector('.container').firstChild);
            
            // Auto-remove after 5 seconds
            setTimeout(() => {
                if (errorDiv.parentNode) {
                    errorDiv.parentNode.removeChild(errorDiv);
                }
            }, 5000);
        }

        function showSuccess(message) {
            const successDiv = document.createElement('div');
            successDiv.className = 'success';
            successDiv.textContent = message;
            
            document.querySelector('.container').insertBefore(successDiv, document.querySelector('.container').firstChild);
            
            setTimeout(() => {
                if (successDiv.parentNode) {
                    successDiv.parentNode.removeChild(successDiv);
                }
            }, 3000);
        }

        // Add confidence and notes auto-save
        document.addEventListener('DOMContentLoaded', function() {
            const confidenceSelect = document.getElementById('confidenceLevel');
            const notesTextarea = document.getElementById('notes');

            if (confidenceSelect) {
                confidenceSelect.addEventListener('change', function() {
                    const currentCat = assessmentState.categories.find(c => c.id === assessmentState.currentCategory);
                    if (currentCat && currentCat.questions[assessmentState.currentQuestion]) {
                        const questionId = currentCat.questions[assessmentState.currentQuestion].subcategory_id;
                        const currentAnswer = document.querySelector('input[name="answer"]:checked');
                        if (currentAnswer) {
                            scheduleImmediateSave(questionId, currentAnswer.value);
                        }
                    }
                });
            }

            if (notesTextarea) {
                let notesTimeout;
                notesTextarea.addEventListener('input', function() {
                    if (notesTimeout) clearTimeout(notesTimeout);
                    
                    notesTimeout = setTimeout(() => {
                        const currentCat = assessmentState.categories.find(c => c.id === assessmentState.currentCategory);
                        if (currentCat && currentCat.questions[assessmentState.currentQuestion]) {
                            const questionId = currentCat.questions[assessmentState.currentQuestion].subcategory_id;
                            const currentAnswer = document.querySelector('input[name="answer"]:checked');
                            if (currentAnswer) {
                                console.log('AUTO-SAVE: Scheduling for question:', questionId, 'value:', currentAnswer.value);
                                scheduleImmediateSave(questionId, currentAnswer.value);
                            }
                        }
                    }, 1000); // Save notes after 1 second of no typing
                });
            }
        });

    </script>
</body>
</html>