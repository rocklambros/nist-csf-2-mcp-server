<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate">
    <meta http-equiv="Pragma" content="no-cache">
    <meta http-equiv="Expires" content="0">
    <title>NIST CSF 2.0 Assessment v2025.09.08-NAVIGATION-FIXED</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            color: #333;
        }
        
        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
        }
        
        .header {
            background: white;
            padding: 24px;
            border-radius: 12px;
            box-shadow: 0 4px 16px rgba(0,0,0,0.1);
            margin-bottom: 24px;
            text-align: center;
        }
        
        .header h1 {
            color: #2c3e50;
            font-size: 2.5rem;
            margin-bottom: 8px;
        }
        
        .header p {
            color: #7f8c8d;
            font-size: 1.1rem;
        }
        
        .progress-section {
            background: white;
            padding: 20px;
            border-radius: 12px;
            box-shadow: 0 4px 16px rgba(0,0,0,0.1);
            margin-bottom: 24px;
        }
        
        .progress-bar {
            background: #ecf0f1;
            border-radius: 25px;
            height: 12px;
            overflow: hidden;
            margin-bottom: 16px;
        }
        
        .progress-fill {
            background: linear-gradient(90deg, #3498db, #2ecc71);
            height: 100%;
            border-radius: 25px;
            transition: width 0.3s ease;
            width: 0%;
        }
        
        .progress-text {
            font-size: 1.1rem;
            font-weight: 600;
            color: #2c3e50;
            text-align: center;
        }
        
        .organization-setup {
            background: white;
            padding: 24px;
            border-radius: 12px;
            box-shadow: 0 4px 16px rgba(0,0,0,0.1);
            margin-bottom: 24px;
        }
        
        .form-group {
            margin-bottom: 20px;
        }
        
        .form-group label {
            display: block;
            margin-bottom: 8px;
            font-weight: 600;
            color: #2c3e50;
        }
        
        .form-group input, .form-group select {
            width: 100%;
            padding: 12px;
            border: 2px solid #ecf0f1;
            border-radius: 8px;
            font-size: 1rem;
            transition: border-color 0.3s ease;
        }
        
        .form-group input:focus, .form-group select:focus {
            outline: none;
            border-color: #3498db;
        }
        
        .btn {
            background: linear-gradient(135deg, #3498db, #2980b9);
            color: white;
            padding: 12px 24px;
            border: none;
            border-radius: 8px;
            font-size: 1rem;
            cursor: pointer;
            transition: transform 0.2s ease;
        }
        
        .btn:hover {
            transform: translateY(-2px);
        }
        
        .btn:disabled {
            opacity: 0.6;
            cursor: not-allowed;
            transform: none;
        }
        
        .category-grid, .function-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 20px;
            margin-bottom: 24px;
        }
        
        .function-cards {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 15px;
            margin-top: 20px;
        }
        
        .function-card {
            background: linear-gradient(135deg, #f8f9fa, #e9ecef);
            border: 2px solid #dee2e6;
            border-radius: 12px;
            padding: 20px;
            text-align: center;
            cursor: pointer;
            transition: all 0.3s ease;
        }
        
        .function-card:hover {
            background: linear-gradient(135deg, #3498db, #2980b9);
            color: white;
            border-color: #2980b9;
            transform: translateY(-5px);
            box-shadow: 0 8px 25px rgba(52, 152, 219, 0.3);
        }
        
        .function-title {
            font-size: 1.4em;
            font-weight: bold;
            margin-bottom: 8px;
        }
        
        .function-id {
            font-size: 0.9em;
            opacity: 0.8;
            font-family: monospace;
        }
        
        .function-description {
            font-size: 0.95em;
            margin: 10px 0;
            line-height: 1.4;
        }
        
        .function-stats {
            font-size: 0.9em;
            color: #666;
            margin-top: 8px;
        }
        
        .function-progress {
            font-size: 0.85em;
            color: #3498db;
            font-weight: bold;
            margin-top: 5px;
        }
        
        .navigation-breadcrumb {
            background: #f8f9fa;
            padding: 12px 16px;
            border-radius: 8px;
            margin-bottom: 20px;
            font-weight: 500;
        }
        
        .breadcrumb-link {
            background: transparent;
            border: none;
            color: #3498db;
            cursor: pointer;
            text-decoration: underline;
            font-size: inherit;
            margin-left: 10px;
        }
        
        .category-card {
            background: white;
            padding: 20px;
            border-radius: 12px;
            box-shadow: 0 4px 16px rgba(0,0,0,0.1);
            cursor: pointer;
            transition: all 0.3s ease;
            border-left: 5px solid #bdc3c7;
        }
        
        .category-card:hover {
            transform: translateY(-4px);
            box-shadow: 0 8px 24px rgba(0,0,0,0.15);
        }
        
        .category-card.completed {
            border-left-color: #27ae60;
        }
        
        .category-card.in-progress {
            border-left-color: #f39c12;
        }
        
        .category-card.not-started {
            border-left-color: #e74c3c;
        }
        
        .category-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 12px;
        }
        
        .category-title {
            font-size: 1.2rem;
            font-weight: 600;
            color: #2c3e50;
        }
        
        .category-progress {
            font-size: 0.9rem;
            font-weight: 600;
        }
        
        .category-progress.completed {
            color: #27ae60;
        }
        
        .category-progress.in-progress {
            color: #f39c12;
        }
        
        .category-progress.not-started {
            color: #e74c3c;
        }
        
        .category-description {
            color: #7f8c8d;
            line-height: 1.5;
        }
        
        .question-container {
            background: white;
            padding: 24px;
            border-radius: 12px;
            box-shadow: 0 4px 16px rgba(0,0,0,0.1);
            margin-bottom: 24px;
            display: none;
        }
        
        .question-header {
            margin-bottom: 20px;
        }
        
        .question-number {
            color: #7f8c8d;
            font-size: 0.9rem;
            font-weight: 600;
        }
        
        .question-text {
            font-size: 1.3rem;
            color: #2c3e50;
            line-height: 1.6;
            margin: 12px 0;
        }
        
        .question-options {
            margin: 20px 0;
        }
        
        .option {
            display: flex;
            align-items: center;
            padding: 12px;
            margin: 8px 0;
            background: #f8f9fa;
            border-radius: 8px;
            cursor: pointer;
            transition: background-color 0.2s ease;
        }
        
        .option:hover {
            background: #e9ecef;
        }
        
        .option input[type="radio"] {
            margin-right: 12px;
        }
        
        .option label {
            cursor: pointer;
            flex: 1;
        }
        
        .confidence-section {
            margin: 20px 0;
            padding: 16px;
            background: #f8f9fa;
            border-radius: 8px;
        }
        
        .confidence-section label {
            display: block;
            margin-bottom: 8px;
            font-weight: 600;
        }
        
        .notes-section {
            margin: 20px 0;
        }
        
        .notes-section textarea {
            width: 100%;
            padding: 12px;
            border: 2px solid #ecf0f1;
            border-radius: 8px;
            font-family: inherit;
            resize: vertical;
            min-height: 80px;
        }
        
        .question-navigation {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-top: 24px;
        }
        
        .auto-save-indicator {
            display: flex;
            align-items: center;
            color: #27ae60;
            font-size: 0.9rem;
        }
        
        .auto-save-indicator.saving {
            color: #f39c12;
        }
        
        .auto-save-indicator.error {
            color: #e74c3c;
        }
        
        .hidden {
            display: none;
        }
        
        .loading {
            text-align: center;
            padding: 40px;
            color: #7f8c8d;
        }
        
        .error {
            background: #fff5f5;
            border: 1px solid #feb2b2;
            color: #c53030;
            padding: 16px;
            border-radius: 8px;
            margin: 16px 0;
        }
        
        .success {
            background: #f0fff4;
            border: 1px solid #9ae6b4;
            color: #22543d;
            padding: 16px;
            border-radius: 8px;
            margin: 16px 0;
        }
        
        @media (max-width: 768px) {
            .category-grid {
                grid-template-columns: 1fr;
            }
            
            .question-navigation {
                flex-direction: column;
                gap: 16px;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>🛡️ NIST CSF 2.0 Comprehensive Assessment</h1>
            <p>Complete cybersecurity framework assessment with persistent progress tracking</p>
        </div>

        <div class="progress-section">
            <div class="progress-bar">
                <div class="progress-fill" id="overallProgress"></div>
            </div>
            <div class="progress-text" id="progressText">Getting started...</div>
        </div>

        <!-- Organization Setup Screen -->
        <div class="organization-setup" id="organizationSetup">
            <h2>Organization Setup</h2>
            <div class="form-group">
                <label for="orgName">Organization Name *</label>
                <input type="text" id="orgName" placeholder="Enter your organization name" required>
            </div>
            
            <div class="form-group">
                <label for="sector">Industry Sector *</label>
                <select id="sector" required>
                    <option value="">Select your industry sector</option>
                    <option value="financial">Financial Services</option>
                    <option value="healthcare">Healthcare</option>
                    <option value="energy">Energy & Utilities</option>
                    <option value="manufacturing">Manufacturing</option>
                    <option value="technology">Technology</option>
                    <option value="government">Government</option>
                    <option value="education">Education</option>
                    <option value="retail">Retail</option>
                    <option value="transportation">Transportation</option>
                    <option value="other">Other</option>
                </select>
            </div>
            
            <div class="form-group">
                <label for="orgSize">Organization Size *</label>
                <select id="orgSize" required>
                    <option value="">Select organization size</option>
                    <option value="small">Small (1-50 employees)</option>
                    <option value="medium">Medium (51-250 employees)</option>
                    <option value="large">Large (251-1000 employees)</option>
                    <option value="enterprise">Enterprise (1000+ employees)</option>
                </select>
            </div>
            
            <div class="form-group">
                <label for="contactEmail">Contact Email</label>
                <input type="email" id="contactEmail" placeholder="contact@organization.com">
            </div>
            
            <button class="btn" onclick="startAssessment()">Start Assessment</button>
        </div>

        <!-- Category Selection Screen -->
        <!-- Function Selection Screen -->
        <div class="function-grid hidden" id="functionSelection">
            <h2>Select NIST CSF 2.0 Function to Assess</h2>
            <p>Choose a cybersecurity function to begin detailed assessment</p>
            <div class="function-cards" id="functionCards">
                <!-- Functions will be populated dynamically -->
            </div>
        </div>

        <div class="category-grid hidden" id="categorySelection">
            <div class="navigation-breadcrumb">
                <span id="functionBreadcrumb"></span> → Categories
                <button onclick="showFunctionSelection()" class="breadcrumb-link">← Back to Functions</button>
            </div>
            <!-- Categories will be populated dynamically -->
        </div>

        <!-- Question Interface -->
        <div class="question-container" id="questionContainer">
            <div class="question-header">
                <div class="question-number" id="questionNumber"></div>
                <div class="question-text" id="questionText"></div>
            </div>

            <div class="question-options" id="questionOptions">
                <!-- Options populated dynamically -->
            </div>

            <div class="confidence-section">
                <label for="confidenceLevel">How confident are you in this assessment?</label>
                <select id="confidenceLevel">
                    <option value="low">Low Confidence</option>
                    <option value="medium" selected>Medium Confidence</option>
                    <option value="high">High Confidence</option>
                </select>
            </div>

            <div class="notes-section">
                <label for="notes">Additional Notes (Optional)</label>
                <textarea id="notes" placeholder="Add any additional context, concerns, or implementation details..."></textarea>
            </div>

            <div class="question-navigation">
                <button class="btn" onclick="previousQuestion()" id="prevBtn">Previous</button>
                <div class="auto-save-indicator" id="saveIndicator">
                    <span id="saveText">Ready to save</span>
                </div>
                <button class="btn" onclick="nextQuestion()" id="nextBtn">Next Question</button>
            </div>
        </div>

        <div id="loadingIndicator" class="loading hidden">
            <div>🔄 Loading assessment data...</div>
        </div>
    </div>

    <script>
        // VERSION CHECK - Add visual indicator that new version loaded
        document.addEventListener('DOMContentLoaded', function() {
            const versionDiv = document.createElement('div');
            versionDiv.innerHTML = '🟢 DEDUPED-CLEAN-QUESTIONS VERSION';
            versionDiv.style.cssText = 'position:fixed;top:10px;right:10px;background:green;color:white;padding:5px;border-radius:3px;z-index:9999;font-size:12px;';
            document.body.appendChild(versionDiv);
            
            // Add reset button for quick testing
            const resetBtn = document.createElement('button');
            resetBtn.innerHTML = '🔄 Reset Assessment';
            resetBtn.style.cssText = 'position:fixed;top:50px;right:10px;background:red;color:white;padding:5px;border-radius:3px;z-index:9999;font-size:12px;cursor:pointer;border:none;';
            resetBtn.onclick = function() {
                console.log('MANUAL RESET: Clearing all data');
                localStorage.clear();
                location.reload();
            };
            document.body.appendChild(resetBtn);
            
            console.log('🟢 WITHDRAWN-CONTROLS-FILTERED VERSION - Clean assessment ready');
        });

        // Global Assessment State
        let assessmentState = {
            sessionId: null,
            organizationId: null,
            profileId: null,
            workflowId: null,
            currentFunction: null,
            currentCategory: null,
            currentQuestion: 0,
            totalQuestions: 424,
            answers: new Map(),
            functions: [],
            categories: [],
            questions: [],
            functionProgress: new Map(),
            categoryProgress: new Map(),
            lastSaveTime: null
        };

        // Configuration
        const MCP_SERVER_URL = 'http://localhost:3001'; // HTTP REST API server
        const AUTO_SAVE_DELAY = 200; // Reduced delay to prevent navigation blocking

        // Initialize Application
        document.addEventListener('DOMContentLoaded', function() {
            initializeApp();
        });

        async function initializeApp() {
            try {
                // Check for existing session
                const savedSession = localStorage.getItem('nist-csf-session');
                if (savedSession) {
                    assessmentState = { ...assessmentState, ...JSON.parse(savedSession) };
                    if (assessmentState.organizationId) {
                        await resumeExistingAssessment();
                        return;
                    }
                }
                
                // Show organization setup for new assessment
                showOrganizationSetup();
            } catch (error) {
                console.error('Initialization error:', error);
                showError('Failed to initialize assessment. Please refresh and try again.');
            }
        }

        function showOrganizationSetup() {
            // Clear any existing assessment data for fresh start
            localStorage.removeItem('nist-csf-session');
            console.log('RESET: Cleared localStorage session data');
            
            // Reset assessment state
            assessmentState.organizationId = null;
            assessmentState.profileId = null;
            assessmentState.sessionId = null;
            assessmentState.workflowId = null;
            assessmentState.currentFunction = null;
            assessmentState.currentCategory = null;
            assessmentState.currentQuestion = 0;
            assessmentState.answers = new Map();
            assessmentState.functionProgress = new Map();
            assessmentState.categoryProgress = new Map();
            console.log('RESET: Assessment state cleared');
            
            document.getElementById('organizationSetup').classList.remove('hidden');
            document.getElementById('functionSelection').classList.add('hidden');
            document.getElementById('categorySelection').classList.add('hidden');
            document.getElementById('questionContainer').style.display = 'none';
        }

        async function startAssessment() {
            try {
                showLoading(true);
                
                // Validate organization form
                const orgName = document.getElementById('orgName').value;
                const sector = document.getElementById('sector').value;
                const orgSize = document.getElementById('orgSize').value;
                const contactEmail = document.getElementById('contactEmail').value;
                
                if (!orgName || !sector || !orgSize) {
                    showError('Please fill in all required organization details.');
                    showLoading(false);
                    return;
                }

                // Create organization profile via MCP
                const profileResult = await callMCPTool('create_profile', {
                    org_name: orgName,
                    sector: sector,
                    size: orgSize,
                    profile_type: 'current',
                    profile_name: `${orgName} - Current State Assessment`,
                    description: `Comprehensive NIST CSF 2.0 assessment for ${orgName}`,
                    contact_email: contactEmail
                });

                if (!profileResult.success) {
                    throw new Error('Failed to create organization profile: ' + (profileResult.error || 'Unknown error'));
                }

                // Update assessment state - handle API response format
                const profileData = profileResult.data || profileResult;
                assessmentState.organizationId = profileData.org_id;
                assessmentState.profileId = profileData.profile_id;
                assessmentState.sessionId = generateSessionId();
                assessmentState.workflowId = `assessment-${Date.now()}`;

                // Save session to localStorage
                saveSessionState();

                // Load functions, categories and questions
                await loadFrameworkData();
                showFunctionSelection();
                
                showLoading(false);

            } catch (error) {
                console.error('Assessment start error:', error);
                showError('Failed to start assessment: ' + error.message);
                showLoading(false);
            }
        }

        async function loadFrameworkData() {
            try {
                // Get NIST CSF framework structure (functions and categories)
                const frameworkResult = await callMCPTool('csf_lookup', {});
                if (!frameworkResult.success) {
                    throw new Error('Failed to load framework structure');
                }

                // Store functions data and filter out deprecated categories
                const frameworkData = frameworkResult.data || frameworkResult;
                const rawFunctions = frameworkData.data || [];
                
                // Use a whitelist approach for valid NIST CSF 2.0 categories (excluding truly deprecated ones)
                const validCategories = new Set([
                    // GOVERN (GV) - 6 categories
                    'GV.OC', 'GV.RM', 'GV.RR', 'GV.PO', 'GV.OV', 'GV.SC',
                    // IDENTIFY (ID) - 3 categories  
                    'ID.AM', 'ID.RA', 'ID.IM',
                    // PROTECT (PR) - 5 categories
                    'PR.AA', 'PR.AT', 'PR.DS', 'PR.IR', 'PR.PS',
                    // DETECT (DE) - 3 categories
                    'DE.AE', 'DE.CM', 'DE.DP', 
                    // RESPOND (RS) - 4 categories
                    'RS.MA', 'RS.AN', 'RS.CO', 'RS.MI',
                    // RECOVER (RC) - 3 categories
                    'RC.CO', 'RC.RP', 'RC.IM'
                ]);
                
                console.log('WHITELIST FILTER: Valid NIST CSF 2.0 categories:', Array.from(validCategories).sort());
                
                assessmentState.functions = rawFunctions.map(funcItem => ({
                    ...funcItem,
                    children: funcItem.children.filter(category => {
                        const isValid = validCategories.has(category.element_identifier);
                        if (!isValid) {
                            console.log('WHITELIST FILTER: Excluding deprecated category:', category.element_identifier);
                        }
                        return isValid;
                    })
                }));
                
                console.log('FRAMEWORK FILTER: Original categories count:', 
                    rawFunctions.reduce((sum, f) => sum + f.children.length, 0));
                console.log('FRAMEWORK FILTER: Filtered categories count:', 
                    assessmentState.functions.reduce((sum, f) => sum + f.children.length, 0));
                
                // Debug category counts per function - correct NIST CSF 2.0 structure
                const expectedCounts = { GV: 6, ID: 3, PR: 5, DE: 3, RS: 4, RC: 3 };
                
                assessmentState.functions.forEach(funcItem => {
                    const func = funcItem.element;
                    const actualCount = funcItem.children.length;
                    const expectedCount = expectedCounts[func.element_identifier] || 0;
                    const status = actualCount === expectedCount ? '✅' : '❌';
                    
                    console.log(`CATEGORIES: ${status} ${func.element_identifier} (${func.title}): ${actualCount}/${expectedCount} categories:`, 
                        funcItem.children.map(c => c.element_identifier).join(', '));
                });

                // Initialize function progress tracking
                assessmentState.functions.forEach(funcItem => {
                    const func = funcItem.element;
                    assessmentState.functionProgress.set(func.element_identifier, {
                        total_categories: funcItem.children.length,
                        completed_categories: 0,
                        percentage: 0
                    });
                });

                // Get all assessment questions - Fix organization_size validation
                const orgSizeElement = document.getElementById('orgSize');
                let orgSize = orgSizeElement?.value || 'medium'; // Default fallback
                
                // Use saved organization data if available (for resume scenarios)
                const savedSession = localStorage.getItem('nist-csf-session');
                if (savedSession) {
                    try {
                        const saved = JSON.parse(savedSession);
                        if (saved.organizationData && saved.organizationData.size) {
                            orgSize = saved.organizationData.size;
                        }
                    } catch (e) {
                        console.warn('Could not parse saved organization data:', e);
                    }
                }
                
                // Validate organization size against API enum requirements
                const validSizes = ['small', 'medium', 'large', 'enterprise'];
                const validatedOrgSize = validSizes.includes(orgSize) ? orgSize : 'medium';
                
                console.log('QUESTIONS API DEBUG:');
                console.log('- orgSize element:', orgSizeElement);
                console.log('- orgSize value:', orgSize);
                console.log('- validated size:', validatedOrgSize);

                const questionsResult = await callMCPTool('get_assessment_questions', {
                    assessment_type: 'detailed',
                    organization_size: validatedOrgSize,
                    include_conditional: true,
                    include_examples: true
                });

                if (!questionsResult.success) {
                    console.error('Questions API failed:', questionsResult);
                    throw new Error(`Failed to load assessment questions: ${questionsResult.error || 'Unknown error'}`);
                }

                // Structure data by categories - handle API response format
                const questionData = questionsResult.data || questionsResult;
                const allQuestions = questionData.questions || [];
                
                // COMPREHENSIVE QUESTION FILTERING
                console.log('QUESTIONS FILTER: Starting with', allQuestions.length, 'questions');
                
                // Step 1: Filter out questions with undefined/null/empty text
                const questionsWithText = allQuestions.filter(q => {
                    const hasValidText = q.question_text && 
                                       q.question_text !== 'undefined' && 
                                       q.question_text.trim().length > 0 &&
                                       !q.question_text.includes('undefined');
                    if (!hasValidText) {
                        console.log('FILTER: Removing question with invalid text:', q.subcategory_id, '->', q.question_text);
                    }
                    return hasValidText;
                });
                
                console.log('QUESTIONS FILTER: After text filtering:', questionsWithText.length);
                
                // Step 2: Deduplicate by subcategory_id (keep first valid one)
                const seenSubcategories = new Set();
                const deduplicatedQuestions = questionsWithText.filter(q => {
                    if (seenSubcategories.has(q.subcategory_id)) {
                        console.log('FILTER: Removing duplicate subcategory:', q.subcategory_id);
                        return false;
                    }
                    seenSubcategories.add(q.subcategory_id);
                    return true;
                });
                
                console.log('QUESTIONS FILTER: After deduplication:', deduplicatedQuestions.length);
                
                // Step 3: Filter by valid NIST CSF 2.0 categories only
                const validQuestions = deduplicatedQuestions.filter(q => {
                    if (!q.subcategory_id) return false;
                    const categoryId = getCategoryFromSubcategory(q.subcategory_id);
                    return validCategories.has(categoryId);
                });
                
                console.log('QUESTIONS FILTER: Final valid questions:', validQuestions.length);
                console.log('QUESTIONS FILTER: Total filtered out:', allQuestions.length - validQuestions.length);
                
                assessmentState.questions = validQuestions;
                assessmentState.totalQuestions = validQuestions.length;
                assessmentState.categories = groupQuestionsByCategory(validQuestions);
                
                // Final verification - show categories and question quality
                console.log('FINAL VALIDATION: Generated from filtered questions:');
                const categoryStats = {};
                let totalCleanQuestions = 0;
                
                assessmentState.categories.forEach(cat => {
                    const funcId = cat.function;
                    if (!categoryStats[funcId]) categoryStats[funcId] = [];
                    categoryStats[funcId].push(cat.id);
                    totalCleanQuestions += cat.questions.length;
                    
                    // Validate no undefined questions made it through
                    const badQuestions = cat.questions.filter(q => 
                        !q.question_text || q.question_text === 'undefined' || q.question_text.includes('undefined')
                    );
                    if (badQuestions.length > 0) {
                        console.error('BAD QUESTIONS DETECTED:', cat.id, badQuestions.map(q => q.subcategory_id));
                    }
                    
                    assessmentState.categoryProgress.set(cat.id, {
                        total: cat.questions.length,
                        completed: 0,
                        percentage: 0
                    });
                });
                
                Object.keys(categoryStats).sort().forEach(funcId => {
                    console.log(`FINAL: ${funcId}: ${categoryStats[funcId].length} categories:`, categoryStats[funcId].sort().join(', '));
                });
                
                console.log('QUALITY CHECK: Total clean questions in assessment:', totalCleanQuestions);
                console.log('QUALITY CHECK: Expected NIST CSF categories with questions for assessment workflow');
                console.log('QUALITY CHECK: No undefined question text should appear in the assessment flow');

                updateOverallProgress();

            } catch (error) {
                throw new Error('Failed to load framework data: ' + error.message);
            }
        }

        function groupQuestionsByCategory(questions) {
            const categoryMap = new Map();
            
            questions.forEach(question => {
                const categoryId = getCategoryFromSubcategory(question.subcategory_id);
                
                if (!categoryMap.has(categoryId)) {
                    categoryMap.set(categoryId, {
                        id: categoryId,
                        name: getCategoryName(categoryId),
                        function: categoryId.substring(0, 2),
                        questions: []
                    });
                }
                
                categoryMap.get(categoryId).questions.push(question);
            });

            return Array.from(categoryMap.values()).sort((a, b) => a.id.localeCompare(b.id));
        }

        function getCategoryName(categoryId) {
            // Map category IDs to full names
            const categoryNames = {
                'GV.OC': 'Organizational Context',
                'GV.RM': 'Risk Management Strategy',
                'GV.RR': 'Roles, Responsibilities, and Authorities',
                'GV.PO': 'Policy',
                'GV.OV': 'Oversight',
                'GV.SC': 'Cybersecurity Supply Chain Risk Management',
                'ID.AM': 'Asset Management',
                'ID.RA': 'Risk Assessment',
                'ID.IM': 'Improvement',
                'ID.BE': 'Business Environment',
                'ID.GV': 'Governance',
                'ID.RM': 'Risk Management Strategy',
                'ID.SC': 'Supply Chain Risk Management',
                'PR.AA': 'Identity Management, Authentication, and Access Control',
                'PR.AT': 'Awareness and Training',
                'PR.DS': 'Data Security',
                'PR.PS': 'Platform Security',
                'PR.IR': 'Technology Infrastructure Resilience',
                'PR.AC': 'Identity Management, Authentication and Access Control',
                'PR.IP': 'Information Protection Processes and Procedures',
                'PR.MA': 'Maintenance',
                'PR.PT': 'Protective Technology',
                'DE.CM': 'Continuous Monitoring',
                'DE.AE': 'Adverse Event Analysis',
                'DE.DP': 'Detection Processes',
                'RS.MA': 'Incident Management',
                'RS.AN': 'Incident Analysis',
                'RS.CO': 'Incident Response Reporting and Communication',
                'RS.MI': 'Incident Mitigation',
                'RS.RP': 'Response Planning',
                'RS.IM': 'Improvements',
                'RC.RP': 'Incident Recovery Plan Execution',
                'RC.CO': 'Incident Recovery Communication',
                'RC.IM': 'Improvements'
            };
            
            return categoryNames[categoryId] || categoryId;
        }

        function showFunctionSelection() {
            document.getElementById('organizationSetup').classList.add('hidden');
            document.getElementById('functionSelection').classList.remove('hidden');
            document.getElementById('categorySelection').classList.add('hidden');
            document.getElementById('questionContainer').style.display = 'none';

            renderFunctionCards();
        }

        function showCategorySelection() {
            document.getElementById('organizationSetup').classList.add('hidden');
            document.getElementById('functionSelection').classList.add('hidden');
            document.getElementById('categorySelection').classList.remove('hidden');
            document.getElementById('questionContainer').style.display = 'none';

            // Update breadcrumb
            const currentFuncData = assessmentState.functions.find(f => f.element.element_identifier === assessmentState.currentFunction);
            if (currentFuncData) {
                document.getElementById('functionBreadcrumb').textContent = 
                    `${currentFuncData.element.element_identifier}: ${currentFuncData.element.title}`;
            }

            renderCategoryCards();
        }

        function renderFunctionCards() {
            const container = document.getElementById('functionCards');
            container.innerHTML = '';

            assessmentState.functions.forEach(funcItem => {
                const func = funcItem.element;
                const progress = assessmentState.functionProgress.get(func.element_identifier) || { percentage: 0 };
                
                const card = document.createElement('div');
                card.className = 'function-card';
                card.onclick = () => selectFunction(func.element_identifier);
                
                card.innerHTML = `
                    <div class="function-title">${func.title}</div>
                    <div class="function-id">${func.element_identifier}</div>
                    <div class="function-description">${func.text || 'Core cybersecurity function'}</div>
                    <div class="function-stats">${funcItem.children.length} categories</div>
                    <div class="function-progress">${progress.percentage}% complete</div>
                `;
                
                container.appendChild(card);
            });
        }

        function selectFunction(functionId) {
            assessmentState.currentFunction = functionId;
            saveSessionState();
            showCategorySelection();
        }

        function renderCategoryCards() {
            const container = document.getElementById('categorySelection');
            
            // Preserve breadcrumb, clear only the cards area
            const breadcrumb = container.querySelector('.navigation-breadcrumb');
            container.innerHTML = '';
            if (breadcrumb) {
                container.appendChild(breadcrumb);
            }

            // Filter categories by current function
            const filteredCategories = assessmentState.categories.filter(category => 
                category.function === assessmentState.currentFunction
            );
            
            console.log('CATEGORY FILTER:', {
                currentFunction: assessmentState.currentFunction,
                allCategories: assessmentState.categories.length,
                filteredCount: filteredCategories.length,
                filteredIds: filteredCategories.map(c => c.id)
            });

            filteredCategories.forEach(category => {
                const progress = assessmentState.categoryProgress.get(category.id);
                const progressClass = progress.percentage === 100 ? 'completed' : 
                                   progress.percentage > 0 ? 'in-progress' : 'not-started';

                const card = document.createElement('div');
                card.className = `category-card ${progressClass}`;
                card.onclick = () => startCategoryAssessment(category.id);
                
                card.innerHTML = `
                    <div class="category-header">
                        <div class="category-title">${category.id}: ${category.name}</div>
                        <div class="category-progress ${progressClass}">${progress.percentage}%</div>
                    </div>
                    <div class="category-description">
                        ${progress.completed}/${progress.total} questions completed
                        <br>Function: ${category.function}
                    </div>
                `;

                container.appendChild(card);
            });
        }

        async function startCategoryAssessment(categoryId) {
            try {
                assessmentState.currentCategory = categoryId;
                const category = assessmentState.categories.find(c => c.id === categoryId);
                
                if (!category) {
                    showError('Category not found');
                    return;
                }

                // Find first unanswered question in category
                let startQuestionIndex = 0;
                for (let i = 0; i < category.questions.length; i++) {
                    if (!assessmentState.answers.has(category.questions[i].subcategory_id)) {
                        startQuestionIndex = i;
                        break;
                    }
                }

                assessmentState.currentQuestion = startQuestionIndex;
                showQuestionInterface(category);

            } catch (error) {
                console.error('Category start error:', error);
                showError('Failed to start category assessment: ' + error.message);
            }
        }

        function showQuestionInterface(category) {
            document.getElementById('categorySelection').classList.add('hidden');
            document.getElementById('questionContainer').style.display = 'block';
            
            renderCurrentQuestion(category);
        }

        function renderCurrentQuestion(category) {
            console.log('RENDER QUESTION: Starting render for category:', category.id);
            console.log('RENDER QUESTION: Question index:', assessmentState.currentQuestion);

            const question = category.questions[assessmentState.currentQuestion];
            if (!question) {
                console.log('RENDER QUESTION: No question found, category completed');
                // Category completed, return to selection
                showCategorySelection();
                return;
            }

            console.log('RENDER QUESTION: Question data:', question.subcategory_id);

            try {
                // Update question display with subcategory labeling
                const questionNumberEl = document.getElementById('questionNumber');
                const questionTextEl = document.getElementById('questionText');
                
                if (!questionNumberEl || !questionTextEl) {
                    console.error('RENDER QUESTION: Required DOM elements not found', {
                        questionNumberEl: !!questionNumberEl,
                        questionTextEl: !!questionTextEl
                    });
                    throw new Error('Required DOM elements not found');
                }
                
                questionNumberEl.textContent = `${category.id} - Question ${assessmentState.currentQuestion + 1} of ${category.questions.length}`;
                questionTextEl.textContent = `${question.subcategory_id}: ${question.question_text}`;
                
                console.log('RENDER QUESTION: Updated question display');

                // Render answer options
                console.log('RENDER QUESTION: Rendering options');
                renderQuestionOptions(question);

                // Load existing answer if available
                console.log('RENDER QUESTION: Loading existing answer');
                loadExistingAnswer(question.subcategory_id);

                // Update navigation buttons
                console.log('RENDER QUESTION: Updating navigation buttons');
                updateNavigationButtons(category);

                console.log('RENDER QUESTION: Render completed successfully');

            } catch (error) {
                console.error('RENDER QUESTION: Error during render:', error);
                throw error;
            }
        }

        function renderQuestionOptions(question) {
            const container = document.getElementById('questionOptions');
            container.innerHTML = '';

            // Use real question options if available, otherwise fallback to standard implementation levels
            const options = question.options || [
                { value: 0, label: 'Not Implemented', description: 'No measures in place' },
                { value: 1, label: 'Initial/Ad Hoc', description: 'Minimal processes, informal documentation' },
                { value: 2, label: 'Developing', description: 'Basic processes defined, some documentation' },
                { value: 3, label: 'Defined', description: 'Formal processes documented and communicated' },
                { value: 4, label: 'Managed', description: 'Processes monitored and measured for effectiveness' },
                { value: 5, label: 'Optimized', description: 'Continuous improvement with advanced automation' }
            ];

            options.forEach(option => {
                const optionDiv = document.createElement('div');
                optionDiv.className = 'option';
                
                optionDiv.innerHTML = `
                    <input type="radio" name="answer" value="${option.value}" id="option_${option.value}">
                    <label for="option_${option.value}">
                        <strong>${option.label}</strong><br>
                        <small>${option.description}</small>
                    </label>
                `;

                // Add auto-save on selection
                optionDiv.querySelector('input').addEventListener('change', function() {
                    if (this.checked) {
                        scheduleAutoSave(question.subcategory_id, this.value);
                    }
                });

                container.appendChild(optionDiv);
            });
        }

        function loadExistingAnswer(questionId) {
            const existingAnswer = assessmentState.answers.get(questionId);
            if (existingAnswer) {
                // Select the radio button
                const radio = document.querySelector(`input[name="answer"][value="${existingAnswer.response_value}"]`);
                if (radio) radio.checked = true;

                // Load confidence and notes
                document.getElementById('confidenceLevel').value = existingAnswer.confidence_level || 'medium';
                document.getElementById('notes').value = existingAnswer.notes || '';
            }
        }

        let saveTimeout;
        async function scheduleAutoSave(questionId, responseValue) {
            console.log('SCHEDULE SAVE: questionId:', questionId, 'responseValue:', responseValue);
            
            // Validate parameters before scheduling
            if (!questionId) {
                console.error('SCHEDULE SAVE ERROR: questionId is null/undefined');
                return;
            }
            if (responseValue === undefined || responseValue === null) {
                console.error('SCHEDULE SAVE ERROR: responseValue is null/undefined');
                return;
            }
            
            // Clear existing timeout
            if (saveTimeout) {
                clearTimeout(saveTimeout);
                console.log('SCHEDULE SAVE: Cleared existing timeout');
            }
            
            // Schedule save with parameter validation
            saveTimeout = setTimeout(async () => {
                console.log('EXECUTING SAVE: questionId:', questionId, 'responseValue:', responseValue);
                await saveAnswer(questionId, responseValue);
            }, AUTO_SAVE_DELAY);
        }

        let isSaving = false;
        
        async function saveAnswer(questionId, responseValue) {
            try {
                // Prevent concurrent saves
                if (isSaving) {
                    console.log('SAVE: Already saving, skipping concurrent save');
                    return;
                }
                
                isSaving = true;
                showSaveIndicator('saving');

                // Validate input parameters before API call
                console.log('SAVE DEBUG: Input validation');
                console.log('- questionId (subcategory_id):', questionId);
                console.log('- responseValue:', responseValue, 'type:', typeof responseValue);
                console.log('- profileId:', assessmentState.profileId);

                if (!questionId) {
                    throw new Error('Missing questionId (subcategory_id)');
                }
                if (!assessmentState.profileId) {
                    throw new Error('Missing profile ID - please restart assessment');
                }
                if (responseValue === undefined || responseValue === null) {
                    throw new Error('Missing response value');
                }

                const answerData = {
                    subcategory_id: questionId,  // questionId is actually subcategory_id from the caller
                    response_value: parseInt(responseValue),  // Ensure numeric value for API
                    confidence_level: document.getElementById('confidenceLevel')?.value || 'medium',
                    notes: document.getElementById('notes')?.value || ''
                };

                console.log('SAVE DEBUG: Request payload:', JSON.stringify({
                    profile_id: assessmentState.profileId,
                    assessment_type: 'detailed',
                    require_all_questions: false,
                    allow_partial_responses: true,
                    responses: [answerData]
                }, null, 2));

                // Save via MCP validate_assessment_responses tool - Use only valid schema parameters
                const requestPayload = {
                    profile_id: assessmentState.profileId,
                    assessment_type: 'detailed',
                    require_all_questions: false,  // Valid schema parameter
                    validate_against_previous: false,  // Skip comparison checks for individual saves
                    check_evidence_requirements: false,  // Skip evidence checks for basic saves
                    responses: [answerData]
                };

                const result = await callMCPTool('validate_assessment_responses', requestPayload);

                // Comprehensive debugging of response structure
                console.log('DEBUG: Full API response:', JSON.stringify(result, null, 2));
                console.log('DEBUG: result.success:', result.success);
                console.log('DEBUG: result.data:', result.data);
                console.log('DEBUG: result.data.success:', result.data?.success);
                console.log('DEBUG: result.data.validation_results:', result.data?.validation_results);

                // BULLETPROOF SUCCESS CHECK: If API returns data and no errors, it's a success
                console.log('DEBUG: Full API response:', JSON.stringify(result, null, 2));
                
                // Ultra-simple success condition: API worked and returned data
                const isApiSuccess = result && result.success;
                const hasResponseData = result.data && result.data.validation_results;
                const hasZeroErrors = hasResponseData && result.data.validation_results.invalid_count === 0;
                
                console.log('ULTRA DEBUG:');
                console.log('- isApiSuccess:', isApiSuccess);
                console.log('- hasResponseData:', hasResponseData);
                console.log('- hasZeroErrors:', hasZeroErrors);
                console.log('- Final success decision:', isApiSuccess && hasZeroErrors);

                // SIMPLIFIED SUCCESS LOGIC: If API call succeeded, treat as success regardless of validation
                console.log('FINAL DECISION: API succeeded?', isApiSuccess);
                
                if (isApiSuccess) {
                    console.log('SUCCESS PATH: Saving answer locally and showing success');
                    // Update local state using subcategory_id as key
                    assessmentState.answers.set(answerData.subcategory_id, answerData);
                    assessmentState.lastSaveTime = new Date();
                    
                    // Update progress
                    updateCategoryProgress();
                    updateOverallProgress();
                    
                    // Save session state
                    saveSessionState();
                    
                    showSaveIndicator('saved');
                } else {
                    console.error('FAILURE PATH: API call failed');
                    console.error('SAVE FAILURE ANALYSIS:');
                    console.error('- API Response Structure:', JSON.stringify(result, null, 2));
                    console.error('- Result Success:', result?.success);
                    console.error('- Result Data:', result?.data);
                    
                    const errorMsg = result.data?.error || result.error || 'API call failed - check console for details';
                    throw new Error(errorMsg);
                }

            } catch (error) {
                console.error('SAVE ERROR DETAILS:', error);
                console.error('SAVE ERROR MESSAGE:', error.message);
                console.error('SAVE ERROR STACK:', error.stack);
                showSaveIndicator('error');
                
                // Keep answer in local state even if API fails (better UX) - Fix variable scope
                const backupData = {
                    subcategory_id: questionId,  // Use function parameter
                    response_value: parseInt(responseValue),
                    confidence_level: document.getElementById('confidenceLevel').value,
                    notes: document.getElementById('notes').value
                };
                
                assessmentState.answers.set(questionId, backupData);
                updateCategoryProgress();
                updateOverallProgress();
                saveSessionState();
                
                // Keep answer in local storage as backup
                localStorage.setItem(`backup-${questionId}`, JSON.stringify({
                    subcategory_id: questionId, 
                    response_value: responseValue, 
                    timestamp: Date.now()
                }));
            } finally {
                isSaving = false;
                console.log('SAVE: Save operation completed, isSaving reset to false');
            }
        }

        function updateCategoryProgress() {
            const currentCat = assessmentState.categories.find(c => c.id === assessmentState.currentCategory);
            if (!currentCat) return;

            let completed = 0;
            currentCat.questions.forEach(q => {
                if (assessmentState.answers.has(q.subcategory_id)) completed++;
            });

            const progress = {
                total: currentCat.questions.length,
                completed: completed,
                percentage: Math.round((completed / currentCat.questions.length) * 100)
            };

            assessmentState.categoryProgress.set(assessmentState.currentCategory, progress);
        }

        function updateOverallProgress() {
            const totalAnswered = assessmentState.answers.size;
            const percentage = Math.round((totalAnswered / assessmentState.totalQuestions) * 100);
            
            document.getElementById('overallProgress').style.width = percentage + '%';
            document.getElementById('progressText').textContent = 
                `${percentage}% Complete - ${totalAnswered}/${assessmentState.totalQuestions} Questions Answered`;
        }

        function showSaveIndicator(status) {
            const indicator = document.getElementById('saveIndicator');
            const text = document.getElementById('saveText');
            
            indicator.className = `auto-save-indicator ${status}`;
            
            switch(status) {
                case 'saving':
                    text.textContent = '💾 Saving...';
                    break;
                case 'saved':
                    text.textContent = '✅ Saved';
                    setTimeout(() => {
                        text.textContent = 'Auto-save enabled';
                        indicator.className = 'auto-save-indicator';
                    }, 2000);
                    break;
                case 'error':
                    text.textContent = '❌ Save failed - stored locally (check console F12)';
                    break;
                default:
                    text.textContent = 'Auto-save enabled';
            }
        }

        function saveSessionState() {
            // Capture organization form data for resume functionality
            const orgSizeElement = document.getElementById('orgSize');
            const orgNameElement = document.getElementById('orgName');
            const orgSectorElement = document.getElementById('orgSector');
            
            const sessionData = {
                sessionId: assessmentState.sessionId,
                organizationId: assessmentState.organizationId,
                profileId: assessmentState.profileId,
                workflowId: assessmentState.workflowId,
                currentFunction: assessmentState.currentFunction,
                currentCategory: assessmentState.currentCategory,
                currentQuestion: assessmentState.currentQuestion,
                answers: Array.from(assessmentState.answers.entries()),
                functionProgress: Array.from(assessmentState.functionProgress.entries()),
                categoryProgress: Array.from(assessmentState.categoryProgress.entries()),
                lastSaveTime: assessmentState.lastSaveTime,
                // Save organization form data for API calls during resume
                organizationData: {
                    size: orgSizeElement?.value || 'medium',
                    name: orgNameElement?.value || '',
                    sector: orgSectorElement?.value || ''
                }
            };
            
            localStorage.setItem('nist-csf-session', JSON.stringify(sessionData));
        }

        async function resumeExistingAssessment() {
            try {
                showLoading(true);
                
                // Restore state from localStorage
                const saved = JSON.parse(localStorage.getItem('nist-csf-session'));
                assessmentState.answers = new Map(saved.answers || []);
                assessmentState.functionProgress = new Map(saved.functionProgress || []);
                assessmentState.categoryProgress = new Map(saved.categoryProgress || []);
                assessmentState.currentFunction = saved.currentFunction;
                
                // Restore organization form data if available
                if (saved.organizationData) {
                    const orgSizeElement = document.getElementById('orgSize');
                    const orgNameElement = document.getElementById('orgName');
                    const orgSectorElement = document.getElementById('orgSector');
                    
                    if (orgSizeElement && saved.organizationData.size) {
                        orgSizeElement.value = saved.organizationData.size;
                    }
                    if (orgNameElement && saved.organizationData.name) {
                        orgNameElement.value = saved.organizationData.name;
                    }
                    if (orgSectorElement && saved.organizationData.sector) {
                        orgSectorElement.value = saved.organizationData.sector;
                    }
                }
                
                // Load framework data
                await loadFrameworkData();
                
                // Navigate to appropriate screen based on saved state
                if (assessmentState.currentFunction) {
                    if (assessmentState.currentCategory) {
                        // Resume in category
                        showCategorySelection();
                    } else {
                        // Resume at category selection for function
                        showCategorySelection();
                    }
                } else {
                    // Resume at function selection
                    showFunctionSelection();
                }
                updateOverallProgress();
                
                showSuccess(`Welcome back! Resuming assessment for organization ID: ${assessmentState.organizationId}`);
                showLoading(false);

            } catch (error) {
                console.error('Resume error:', error);
                console.error('Resume error details:', error.message);
                console.error('Resume error stack:', error.stack);
                showError(`Failed to resume assessment: ${error.message}. Starting fresh...`);
                localStorage.removeItem('nist-csf-session');
                showOrganizationSetup();
                showLoading(false);
            }
        }

        let nextButtonClickCount = 0;
        
        function nextQuestion() {
            nextButtonClickCount++;
            console.log('NEXT QUESTION: Button clicked - Count:', nextButtonClickCount);
            
            // Update click counter display
            const clickCounter = document.getElementById('clickCounter');
            if (clickCounter) {
                clickCounter.innerHTML = `Next Button Clicks: ${nextButtonClickCount}`;
            }
            
            // Prevent multiple rapid clicks
            const nextBtn = document.getElementById('nextBtn');
            if (nextBtn.disabled) {
                console.log('NEXT QUESTION: Button already disabled, ignoring click');
                return;
            }
            
            // Disable button temporarily
            nextBtn.disabled = true;
            nextBtn.style.opacity = '0.6';
            
            console.log('NEXT QUESTION: Current state:', {
                currentCategory: assessmentState.currentCategory,
                currentQuestion: assessmentState.currentQuestion,
                totalCategories: assessmentState.categories.length
            });

            const currentCat = assessmentState.categories.find(c => c.id === assessmentState.currentCategory);
            if (!currentCat) {
                console.error('NEXT QUESTION: Current category not found');
                nextBtn.disabled = false;
                nextBtn.style.opacity = '1';
                return;
            }

            console.log('NEXT QUESTION: Current category:', currentCat.id, 'Total questions:', currentCat.questions.length);

            // Prevent navigation while saving is in progress
            if (isSaving) {
                console.log('NEXT QUESTION: Save in progress, deferring navigation...');
                // Don't navigate while save is happening - user will need to click again
                nextBtn.disabled = false;
                nextBtn.style.opacity = '1';
                return;
            }

            // Clear any pending auto-save before navigation
            if (saveTimeout) {
                console.log('NEXT QUESTION: Clearing pending auto-save');
                clearTimeout(saveTimeout);
                saveTimeout = null;
            }

            if (assessmentState.currentQuestion < currentCat.questions.length - 1) {
                console.log('NEXT QUESTION: Advancing from', assessmentState.currentQuestion, 'to', assessmentState.currentQuestion + 1);
                assessmentState.currentQuestion++;
                
                try {
                    renderCurrentQuestion(currentCat);
                    console.log('NEXT QUESTION: Successfully rendered question', assessmentState.currentQuestion);
                    // Reset click counter on successful navigation
                    nextButtonClickCount = 0;
                    if (clickCounter) {
                        clickCounter.innerHTML = `Next Button Clicks: ${nextButtonClickCount}`;
                    }
                } catch (error) {
                    console.error('NEXT QUESTION: Error rendering question:', error);
                }
            } else {
                console.log('NEXT QUESTION: Category completed, returning to selection');
                // Category completed, return to selection
                showCategorySelection();
            }

            // Re-enable button after short delay
            setTimeout(() => {
                nextBtn.disabled = false;
                nextBtn.style.opacity = '1';
                console.log('NEXT QUESTION: Button re-enabled');
            }, 100);
        }

        function previousQuestion() {
            const currentCat = assessmentState.categories.find(c => c.id === assessmentState.currentCategory);
            if (!currentCat) return;

            if (assessmentState.currentQuestion > 0) {
                assessmentState.currentQuestion--;
                renderCurrentQuestion(currentCat);
            } else {
                // Return to category selection
                showCategorySelection();
            }
        }

        function updateNavigationButtons(category) {
            const prevBtn = document.getElementById('prevBtn');
            const nextBtn = document.getElementById('nextBtn');
            
            prevBtn.style.display = assessmentState.currentQuestion > 0 ? 'block' : 'none';
            
            if (assessmentState.currentQuestion === category.questions.length - 1) {
                nextBtn.textContent = 'Back to Categories';
            } else {
                nextBtn.textContent = 'Next Question';
            }
        }

        // Utility Functions
        function generateSessionId() {
            return 'session-' + Date.now() + '-' + Math.random().toString(36).substr(2, 9);
        }

        async function callMCPTool(toolName, params) {
            try {
                console.log(`Calling MCP tool: ${toolName}`, params);
                
                const response = await fetch(`${MCP_SERVER_URL}/api/tools/${toolName}`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Accept': 'application/json'
                    },
                    body: JSON.stringify(params)
                });

                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                }

                const result = await response.json();
                console.log(`MCP tool result:`, result);
                
                return result;

            } catch (error) {
                console.error(`MCP tool error (${toolName}):`, error);
                return { 
                    success: false, 
                    error: `Failed to call ${toolName}: ${error.message}` 
                };
            }
        }

        // Utility function to extract category from subcategory ID
        function getCategoryFromSubcategory(subcategoryId) {
            // Extract category (e.g., "GV.OC" from "GV.OC-01")
            return subcategoryId.split('-')[0];
        }

        function showLoading(show) {
            const indicator = document.getElementById('loadingIndicator');
            if (show) {
                indicator.classList.remove('hidden');
            } else {
                indicator.classList.add('hidden');
            }
        }

        function showError(message) {
            // Create and show error message
            const errorDiv = document.createElement('div');
            errorDiv.className = 'error';
            errorDiv.textContent = message;
            
            document.querySelector('.container').insertBefore(errorDiv, document.querySelector('.container').firstChild);
            
            // Auto-remove after 5 seconds
            setTimeout(() => {
                if (errorDiv.parentNode) {
                    errorDiv.parentNode.removeChild(errorDiv);
                }
            }, 5000);
        }

        function showSuccess(message) {
            const successDiv = document.createElement('div');
            successDiv.className = 'success';
            successDiv.textContent = message;
            
            document.querySelector('.container').insertBefore(successDiv, document.querySelector('.container').firstChild);
            
            setTimeout(() => {
                if (successDiv.parentNode) {
                    successDiv.parentNode.removeChild(successDiv);
                }
            }, 3000);
        }

        // Add confidence and notes auto-save
        document.addEventListener('DOMContentLoaded', function() {
            const confidenceSelect = document.getElementById('confidenceLevel');
            const notesTextarea = document.getElementById('notes');

            if (confidenceSelect) {
                confidenceSelect.addEventListener('change', function() {
                    const currentCat = assessmentState.categories.find(c => c.id === assessmentState.currentCategory);
                    if (currentCat && currentCat.questions[assessmentState.currentQuestion]) {
                        const questionId = currentCat.questions[assessmentState.currentQuestion].subcategory_id;
                        const currentAnswer = document.querySelector('input[name="answer"]:checked');
                        if (currentAnswer) {
                            scheduleAutoSave(questionId, currentAnswer.value);
                        }
                    }
                });
            }

            if (notesTextarea) {
                let notesTimeout;
                notesTextarea.addEventListener('input', function() {
                    if (notesTimeout) clearTimeout(notesTimeout);
                    
                    notesTimeout = setTimeout(() => {
                        const currentCat = assessmentState.categories.find(c => c.id === assessmentState.currentCategory);
                        if (currentCat && currentCat.questions[assessmentState.currentQuestion]) {
                            const questionId = currentCat.questions[assessmentState.currentQuestion].subcategory_id;
                            const currentAnswer = document.querySelector('input[name="answer"]:checked');
                            if (currentAnswer) {
                                console.log('AUTO-SAVE: Scheduling for question:', questionId, 'value:', currentAnswer.value);
                                scheduleAutoSave(questionId, currentAnswer.value);
                            }
                        }
                    }, 1000); // Save notes after 1 second of no typing
                });
            }
        });

    </script>
</body>
</html>