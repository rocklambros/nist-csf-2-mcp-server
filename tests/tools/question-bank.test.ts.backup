/**
 * Comprehensive unit tests for Question Bank tools
 * Tests get_assessment_questions, validate_assessment_responses, and get_question_context
 */

import { describe, it, expect, beforeAll, afterAll, beforeEach, jest } from '@jest/globals';
import { getAssessmentQuestions } from '../../src/tools/get_assessment_questions.js';
import { validateAssessmentResponses } from '../../src/tools/validate_assessment_responses.js';
import { getQuestionContext } from '../../src/tools/get_question_context.js';
import { questionBankService } from '../../src/services/question-bank.js';
// Remove TestDatabase dependency, using mocks instead

// Mock the logger to avoid console spam during tests
jest.mock('../../src/utils/enhanced-logger.js', () => ({
  logger: {
    info: jest.fn(),
    warn: jest.fn(),
    error: jest.fn(),
    debug: jest.fn()
  }
}));

// Mock the framework loader
jest.mock('../../src/services/framework-loader.js', () => ({
  getFrameworkLoader: () => ({
    getElement: jest.fn(),
    queryElements: jest.fn()
  })
}));

// Mock the database module to avoid import.meta.url issues
jest.mock('../../src/db/database.js', () => ({
  getDatabase: jest.fn(() => ({
    prepare: jest.fn(() => ({
      all: jest.fn(() => []),
      get: jest.fn(() => null),
      run: jest.fn(() => ({ changes: 0 }))
    })),
    close: jest.fn()
  }))
}));

// Mock the question bank service
jest.mock('../../src/services/question-bank.js', () => ({
  questionBankService: {
    getAssessmentQuestions: jest.fn(),
    getQuestionContext: jest.fn()
  }
}));

describe('Question Bank Tools', () => {
  // All dependencies are mocked, no database setup needed

  beforeEach(() => {
    jest.clearAllMocks();
  });

  describe('get_assessment_questions', () => {
    const mockQuestions = [
      {
        subcategory_id: 'GV.OC-01',
        question_text: 'Rate your cybersecurity strategy implementation',
        question_type: 'maturity_rating',
        options: [
          { value: 0, label: 'Not Implemented', description: 'No implementation' },
          { value: 1, label: 'Initial', description: 'Basic implementation' },
          { value: 2, label: 'Developing', description: 'Standard implementation' },
          { value: 3, label: 'Defined', description: 'Advanced implementation' }
        ],
        help_text: 'Consider your current processes and documentation',
        examples: ['Written strategy document', 'Board approval'],
        category: 'GV.OC',
        function: 'GV',
        required: true,
        weight: 1.5
      },
      {
        subcategory_id: 'ID.AM-01',
        question_text: 'Rate your asset management implementation',
        question_type: 'maturity_rating',
        options: [
          { value: 0, label: 'Not Implemented' },
          { value: 1, label: 'Initial' },
          { value: 2, label: 'Developing' },
          { value: 3, label: 'Defined' }
        ],
        category: 'ID.AM',
        function: 'ID',
        required: false,
        weight: 1.0
      }
    ];

    beforeEach(() => {
      (questionBankService.getAssessmentQuestions as jest.Mock).mockResolvedValue(mockQuestions);
    });

    it('should retrieve questions for detailed assessment', async () => {
      const result = await getAssessmentQuestions({
        assessment_type: 'detailed',
        include_examples: true,
        include_references: false
      });

      expect(result.success).toBe(true);
      expect(result.total_questions).toBe(2);
      expect(result.assessment_type).toBe('detailed');
      expect(result.questions).toHaveLength(2);
      expect(result.questions[0].subcategory_id).toBe('GV.OC-01');
      expect(result.questions[0].question_type).toBe('maturity_rating');
      
      expect(result.metadata).toBeDefined();
      expect(result.metadata.functions_covered).toEqual(['GV', 'ID']);
      expect(result.metadata.categories_covered).toEqual(['GV.OC', 'ID.AM']);
      expect(result.metadata.required_questions).toBe(1);
      expect(result.metadata.optional_questions).toBe(1);
      expect(result.metadata.estimated_completion_time).toBeDefined();
      expect(result.metadata.generation_time).toBeDefined();
    });

    it('should retrieve questions filtered by function', async () => {
      const governQuestions = mockQuestions.filter(q => q.function === 'GV');
      (questionBankService.getAssessmentQuestions as jest.Mock).mockResolvedValue(governQuestions);

      const result = await getAssessmentQuestions({
        function: 'GV',
        assessment_type: 'detailed'
      });

      expect(result.success).toBe(true);
      expect(result.questions).toHaveLength(1);
      expect(result.questions[0].function).toBe('GV');
      expect(questionBankService.getAssessmentQuestions).toHaveBeenCalledWith(
        expect.objectContaining({ function: 'GV' })
      );
    });

    it('should retrieve questions filtered by category', async () => {
      const categoryQuestions = mockQuestions.filter(q => q.category === 'GV.OC');
      (questionBankService.getAssessmentQuestions as jest.Mock).mockResolvedValue(categoryQuestions);

      const result = await getAssessmentQuestions({
        category: 'GV.OC',
        assessment_type: 'detailed'
      });

      expect(result.success).toBe(true);
      expect(result.questions).toHaveLength(1);
      expect(result.questions[0].category).toBe('GV.OC');
    });

    it('should retrieve questions for quick assessment', async () => {
      const quickQuestions = mockQuestions.map(q => ({
        ...q,
        question_type: 'implementation_status',
        options: [
          { value: 0, label: 'Not Implemented' },
          { value: 1, label: 'Partially Implemented' },
          { value: 2, label: 'Largely Implemented' },
          { value: 3, label: 'Fully Implemented' }
        ]
      }));
      (questionBankService.getAssessmentQuestions as jest.Mock).mockResolvedValue(quickQuestions);

      const result = await getAssessmentQuestions({
        assessment_type: 'quick',
        organization_size: 'small'
      });

      expect(result.success).toBe(true);
      expect(result.assessment_type).toBe('quick');
      expect(result.questions[0].question_type).toBe('implementation_status');
      expect(result.metadata.estimated_completion_time).toBe('2m'); // Shorter for quick assessment
    });

    it('should retrieve questions for specific subcategories', async () => {
      const specificQuestions = [mockQuestions[0]]; // Only GV.OC-01
      (questionBankService.getAssessmentQuestions as jest.Mock).mockResolvedValue(specificQuestions);

      const result = await getAssessmentQuestions({
        subcategory_ids: ['GV.OC-01'],
        assessment_type: 'detailed'
      });

      expect(result.success).toBe(true);
      expect(result.questions).toHaveLength(1);
      expect(result.questions[0].subcategory_id).toBe('GV.OC-01');
      expect(questionBankService.getAssessmentQuestions).toHaveBeenCalledWith(
        expect.objectContaining({ subcategory_ids: ['GV.OC-01'] })
      );
    });

    it('should handle service errors gracefully', async () => {
      (questionBankService.getAssessmentQuestions as jest.Mock).mockRejectedValue(new Error('Service unavailable'));

      const result = await getAssessmentQuestions({
        assessment_type: 'detailed'
      });

      expect(result.success).toBe(false);
      expect(result.error).toBe('Failed to retrieve assessment questions');
      expect(result.message).toBe('Service unavailable');
    });

    it('should validate input parameters', async () => {
      const result = await getAssessmentQuestions({
        function: 'INVALID' as any,
        assessment_type: 'detailed'
      });

      expect(result.success).toBe(false);
      expect(result.error).toBe('Invalid input parameters');
      expect(result.details).toBeDefined();
      expect(result.details[0].field).toBe('function');
    });

    it('should calculate completion time correctly', async () => {
      // Test with different assessment types and question counts
      const manyQuestions = Array(20).fill(mockQuestions[0]);
      (questionBankService.getAssessmentQuestions as jest.Mock).mockResolvedValue(manyQuestions);

      const detailedResult = await getAssessmentQuestions({
        assessment_type: 'detailed'
      });
      expect(detailedResult.metadata.estimated_completion_time).toBe('1h 0m');

      const quickResult = await getAssessmentQuestions({
        assessment_type: 'quick'
      });
      expect(quickResult.metadata.estimated_completion_time).toBe('20m');
    });
  });

  describe('validate_assessment_responses', () => {
    const mockQuestions = [
      {
        subcategory_id: 'GV.OC-01',
        question_type: 'maturity_rating',
        options: [
          { value: 0, label: 'Not Implemented' },
          { value: 1, label: 'Initial' },
          { value: 2, label: 'Developing' },
          { value: 3, label: 'Defined' }
        ],
        required: true
      },
      {
        subcategory_id: 'ID.AM-01',
        question_type: 'maturity_rating',
        options: [
          { value: 0, label: 'Not Implemented' },
          { value: 1, label: 'Initial' },
          { value: 2, label: 'Developing' },
          { value: 3, label: 'Defined' }
        ],
        required: false
      }
    ];

    beforeEach(async () => {
      (questionBankService.getAssessmentQuestions as jest.Mock).mockResolvedValue(mockQuestions);
      
      // Create test profile in database
      await mockDb.prepare(`
        INSERT INTO profiles (profile_id, profile_name, profile_type, org_id, created_at)
        VALUES (?, ?, ?, ?, ?)
      `).run('TEST-PROFILE-001', 'Test Profile', 'current', 'TEST-ORG', new Date().toISOString());
    });

    it('should validate complete and correct responses', async () => {
      const validResponses = [
        {
          subcategory_id: 'GV.OC-01',
          response_value: 2,
          confidence_level: 'high' as const,
          evidence: 'Written cybersecurity strategy document',
          assessed_by: 'Security Team'
        },
        {
          subcategory_id: 'ID.AM-01',
          response_value: 1,
          confidence_level: 'medium' as const,
          notes: 'Asset inventory in development'
        }
      ];

      const result = await validateAssessmentResponses({
        profile_id: 'TEST-PROFILE-001',
        responses: validResponses,
        assessment_type: 'detailed'
      }, mockDb);

      expect(result.success).toBe(true);
      expect(result.validation_results.is_valid).toBe(true);
      expect(result.validation_results.missing_required).toHaveLength(0);
      expect(result.validation_results.invalid_responses).toHaveLength(0);
      expect(result.validation_results.completeness_percentage).toBe(100);
      expect(result.validation_results.validation_summary.required_answered).toBe(1);
      expect(result.validation_results.validation_summary.optional_answered).toBe(1);
    });

    it('should detect missing required questions', async () => {
      const incompleteResponses = [
        {
          subcategory_id: 'ID.AM-01',
          response_value: 1,
          confidence_level: 'medium' as const
        }
        // Missing required GV.OC-01
      ];

      const result = await validateAssessmentResponses({
        profile_id: 'TEST-PROFILE-001',
        responses: incompleteResponses,
        assessment_type: 'detailed'
      }, mockDb);

      expect(result.success).toBe(true);
      expect(result.validation_results.is_valid).toBe(false);
      expect(result.validation_results.missing_required).toContain('GV.OC-01');
      expect(result.validation_results.completeness_percentage).toBe(50);
    });

    it('should detect invalid response values', async () => {
      const invalidResponses = [
        {
          subcategory_id: 'GV.OC-01',
          response_value: 'invalid' as any, // Should be number
          confidence_level: 'high' as const
        },
        {
          subcategory_id: 'ID.AM-01',
          response_value: 5, // Outside valid range (0-3)
          confidence_level: 'medium' as const
        }
      ];

      const result = await validateAssessmentResponses({
        profile_id: 'TEST-PROFILE-001',
        responses: invalidResponses,
        assessment_type: 'detailed'
      }, mockDb);

      expect(result.success).toBe(true);
      expect(result.validation_results.is_valid).toBe(false);
      expect(result.validation_results.invalid_responses).toHaveLength(2);
      
      const firstError = result.validation_results.invalid_responses[0];
      expect(firstError.subcategory_id).toBe('GV.OC-01');
      expect(firstError.issue).toBe('Response must be a number');
      
      const secondError = result.validation_results.invalid_responses[1];
      expect(secondError.subcategory_id).toBe('ID.AM-01');
      expect(secondError.issue).toBe('Response value not in valid options');
    });

    it('should warn about responses to unknown subcategories', async () => {
      const responsesWithUnknown = [
        {
          subcategory_id: 'GV.OC-01',
          response_value: 2,
          confidence_level: 'high' as const
        },
        {
          subcategory_id: 'UNKNOWN-01', // Not in expected questions
          response_value: 1,
          confidence_level: 'low' as const
        }
      ];

      const result = await validateAssessmentResponses({
        profile_id: 'TEST-PROFILE-001',
        responses: responsesWithUnknown,
        assessment_type: 'detailed'
      }, mockDb);

      expect(result.success).toBe(true);
      expect(result.validation_results.warnings).toContain('Response for unknown subcategory: UNKNOWN-01');
    });

    it('should check evidence requirements for critical responses', async () => {
      const responsesWithoutEvidence = [
        {
          subcategory_id: 'GV.OC-01',
          response_value: 0, // Low score for critical subcategory
          confidence_level: 'high' as const
          // No evidence provided
        }
      ];

      const result = await validateAssessmentResponses({
        profile_id: 'TEST-PROFILE-001',
        responses: responsesWithoutEvidence,
        assessment_type: 'detailed',
        check_evidence_requirements: true
      }, mockDb);

      expect(result.success).toBe(true);
      expect(result.validation_results.warnings).toContain('Critical response for GV.OC-01 should include evidence');
    });

    it('should handle non-existent profile', async () => {
      const result = await validateAssessmentResponses({
        profile_id: 'NON-EXISTENT',
        responses: [
          {
            subcategory_id: 'GV.OC-01',
            response_value: 1,
            confidence_level: 'medium' as const
          }
        ]
      }, mockDb);

      expect(result.success).toBe(false);
      expect(result.error).toBe('Failed to validate assessment responses');
      expect(result.message).toContain('Profile NON-EXISTENT not found');
    });

    it('should validate input parameters', async () => {
      const result = await validateAssessmentResponses({
        profile_id: '', // Invalid empty profile ID
        responses: []   // Invalid empty responses
      }, mockDb);

      expect(result.success).toBe(false);
      expect(result.error).toBe('Invalid input parameters');
      expect(result.details).toBeDefined();
    });

    it('should require all questions when specified', async () => {
      const partialResponses = [
        {
          subcategory_id: 'GV.OC-01',
          response_value: 2,
          confidence_level: 'high' as const
        }
        // Missing ID.AM-01
      ];

      const result = await validateAssessmentResponses({
        profile_id: 'TEST-PROFILE-001',
        responses: partialResponses,
        assessment_type: 'detailed',
        require_all_questions: true
      }, mockDb);

      expect(result.success).toBe(true);
      expect(result.validation_results.is_valid).toBe(false);
      expect(result.validation_results.completeness_percentage).toBe(50);
    });
  });

  describe('get_question_context', () => {
    const mockContext = {
      subcategory_id: 'GV.OC-01',
      subcategory_text: 'The organizational mission is understood and informs cybersecurity risk management',
      category_text: "The circumstances surrounding the organization's cybersecurity risk management decisions are understood",
      function_text: "The organization's cybersecurity risk management strategy is established",
      implementation_examples: [
        "Share the organization's mission to provide a basis for identifying risks",
        'Document how cybersecurity strategy supports business objectives'
      ],
      references: ['NIST CSF 2.0 - GV.OC-01', 'https://www.nist.gov/cyberframework'],
      related_subcategories: ['GV.OC-02', 'GV.OC-03'],
      risk_factors: ['Governance gaps', 'Policy violations', 'Compliance failures'],
      common_challenges: ['Resource constraints', 'Skills gaps', 'Technology limitations'],
      best_practices: ['Start with risk assessment', 'Engage stakeholders early'],
      sector_specific_guidance: ['Consider regulatory requirements', 'Focus on business alignment']
    };

    beforeEach(() => {
      (questionBankService.getQuestionContext as jest.Mock).mockResolvedValue(mockContext);
    });

    it('should retrieve comprehensive context for a subcategory', async () => {
      const result = await getQuestionContext({
        subcategory_id: 'GV.OC-01',
        include_implementation_examples: true,
        include_references: true
      });

      expect(result.success).toBe(true);
      expect(result.subcategory_id).toBe('GV.OC-01');
      expect(result.context).toBeDefined();
      expect(result.context.subcategory_text).toBe(mockContext.subcategory_text);
      expect(result.context.implementation_examples).toHaveLength(2);
      expect(result.context.references).toHaveLength(2);

      expect(result.guidance).toBeDefined();
      expect(result.guidance.assessment_tips).toBeDefined();
      expect(result.guidance.evidence_suggestions).toBeDefined();
      expect(result.guidance.common_pitfalls).toBeDefined();
      expect(result.guidance.maturity_indicators).toBeDefined();

      expect(result.metadata).toBeDefined();
      expect(result.metadata.function).toBe('GV');
      expect(result.metadata.category).toBe('GV.OC');
      expect(result.metadata.complexity_level).toBeDefined();
      expect(result.metadata.typical_implementation_time).toBeDefined();
      expect(result.metadata.related_frameworks).toBeDefined();
    });

    it('should provide organization-specific context', async () => {
      const contextWithOrg = {
        ...mockContext,
        contextualized_examples: [
          'Document how cybersecurity protects patient care delivery',
          'Align security strategy with HIPAA compliance requirements'
        ]
      };
      (questionBankService.getQuestionContext as jest.Mock).mockResolvedValue(contextWithOrg);

      const result = await getQuestionContext({
        subcategory_id: 'GV.OC-01',
        organization_context: {
          sector: 'healthcare',
          size: 'medium'
        },
        include_implementation_examples: true
      });

      expect(result.success).toBe(true);
      expect(result.context.contextualized_examples).toBeDefined();
      expect(result.context.contextualized_examples[0]).toContain('patient care');
      
      expect(result.guidance.evidence_suggestions).toContain('HIPAA compliance documentation');
      expect(result.metadata.typical_implementation_time).toBe('1-2 months');
    });

    it('should provide risk assessment guidance', async () => {
      const result = await getQuestionContext({
        subcategory_id: 'GV.OC-01',
        include_risk_factors: true
      });

      expect(result.success).toBe(true);
      expect(result.context.risk_assessment_guidance).toBeDefined();
      expect(result.context.risk_assessment_guidance.risk_evaluation_steps).toBeDefined();
      expect(result.context.risk_assessment_guidance.risk_factors).toBeDefined();
    });

    it('should provide implementation roadmap', async () => {
      const result = await getQuestionContext({
        subcategory_id: 'GV.OC-01',
        include_best_practices: true,
        organization_context: {
          sector: 'technology',
          size: 'large'
        }
      });

      expect(result.success).toBe(true);
      expect(result.context.implementation_roadmap).toBeDefined();
      expect(result.context.implementation_roadmap.implementation_phases).toBeDefined();
      expect(result.context.implementation_roadmap.success_factors).toBeDefined();
      
      const phases = result.context.implementation_roadmap.implementation_phases;
      expect(phases).toHaveLength(4);
      expect(phases[0].phase).toBe('Assessment & Planning');
    });

    it('should handle service errors gracefully', async () => {
      (questionBankService.getQuestionContext as jest.Mock).mockRejectedValue(new Error('Subcategory not found'));

      const result = await getQuestionContext({
        subcategory_id: 'INVALID-01'
      });

      expect(result.success).toBe(false);
      expect(result.error).toBe('Failed to retrieve question context');
      expect(result.message).toBe('Subcategory not found');
    });

    it('should validate input parameters', async () => {
      const result = await getQuestionContext({
        subcategory_id: '', // Invalid empty subcategory ID
        organization_context: {
          sector: 'healthcare',
          size: 'invalid' as any // Invalid size
        }
      });

      expect(result.success).toBe(false);
      expect(result.error).toBe('Invalid input parameters');
      expect(result.details).toBeDefined();
    });

    it('should provide sector-specific guidance', async () => {
      const testCases = [
        { sector: 'healthcare', expected: 'HIPAA' },
        { sector: 'finance', expected: 'PCI-DSS' },
        { sector: 'government', expected: 'FedRAMP' },
        { sector: 'technology', expected: 'intellectual property' }
      ];

      for (const testCase of testCases) {
        const result = await getQuestionContext({
          subcategory_id: 'GV.OC-01',
          organization_context: {
            sector: testCase.sector,
            size: 'medium'
          }
        });

        expect(result.success).toBe(true);
        expect(result.guidance.evidence_suggestions.join(' ')).toContain(testCase.expected);
      }
    });

    it('should provide maturity level indicators', async () => {
      const result = await getQuestionContext({
        subcategory_id: 'GV.OC-01'
      });

      expect(result.success).toBe(true);
      expect(result.guidance.maturity_indicators).toBeDefined();
      expect(result.guidance.maturity_indicators['Level 0 - Not Implemented']).toBeDefined();
      expect(result.guidance.maturity_indicators['Level 3 - Defined']).toBeDefined();
      expect(result.guidance.maturity_indicators['Level 5 - Optimized']).toBeDefined();
    });
  });
});